{"meta":{"title":"xiao-linxin","subtitle":null,"description":null,"author":"xiao-linxin","url":"http://yoursite.com"},"pages":[{"title":"404","date":"2019-01-23T18:11:10.000Z","updated":"2019-01-23T18:11:10.526Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-26T00:22:13.181Z","updated":"2019-01-25T21:52:10.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2019-01-23T18:11:06.000Z","updated":"2019-01-23T18:11:06.126Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-01-26T00:22:16.452Z","updated":"2019-01-25T21:52:10.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"php常识","slug":"php常识（一）","date":"2016-07-09T16:00:00.000Z","updated":"2019-03-01T11:15:02.403Z","comments":true,"path":"2016/07/10/php常识（一）/","link":"","permalink":"http://yoursite.com/2016/07/10/php常识（一）/","excerpt":"","text":"php常识（一） 1.普通字符串处理函数和mb_系列函数的区别：不同编码的个别语言（比如中文）所占字节数不同，一个汉字在GB2312编码下占2个字节，在UTF-8（是变长编码）编码下占2-3个字节，普通字符串处理函数是按每个字符1字节来处理的，而mb_系列的函数在使用时可以多指定一个编码参数，方便处理不同编码的中文。最简单的例子，strlen() 会返回一个字符串所占字节数，而mb_strlen()会返回一个字符串的字符数。再比如，substr($str2, 2, 2)在$str为中文时可能会正好截取到一个汉字的一部分，这时就会发生乱码，而mb_substr($str, 2, 2, ‘utf-8’)指定编码后就不会发生乱码问题了，中文时即是取几个汉字。 2.&amp; 引用，结合案例分析PHP 的引用允许用两个变量来指向同一个内容。 1$a = &amp; $b; $a 和 $b 在这里是完全相同的，这并不是 $a 指向了 $b 或者相反，而是 $a 和 $b 指向了同一个地方。 引用做的第二件事是用引用传递变量。 12345function foo(&amp; $var) &#123; $var++;&#125;$a = 5;foo($a); 将使 $a 变成 6。这是因为在 foo 函数中变量 $var 指向了和 $a 指向的同一个内容。 引用不是指针，下面的结构不会产生预期的效果： 12345function foo(&amp; $var) &#123; $var = &amp; $GLOBALS[&quot;baz&quot;];&#125;foo($bar); 当 unset 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了。例如： 123$a = 1;$b =&amp; $a;unset($a); 不会 unset $b，只是 $a。 3.== 与 === 区别== 是不带类型比较是否相同（比如数字100 == ‘100’结果为true） === 是带类型比较是否相同（比如100 == ‘100’结果为false） 4.isset 与 empty 区别 5.全部魔术函数理解 __construct 类的构造函数，常用来给类的属性赋值。 注意事项：如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()，如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。 __destruct 析构函数，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 call，callStatic 在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用，作为调用类中不存在的方法时对开发者的一个友好提示。 set，get，isset ，unset 在给不可访问属性赋值时，__set() 会被调用； 读取不可访问属性的值时，__get() 会被调用； 当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用； 当对不可访问属性调用 unset() 时，__unset() 会被调用。 sleep，wakeup serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。 如果存在，该方法会先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误，返回父类的私有成员的名字，常用于提交未提交的数据，或类似的清理操作。 与之相反，unserialize() 会检查是否存在一个 wakeup() 方法。如果存在，则会先调用 wakeup 方法，预先准备对象需要的资源。__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 __toString 用于当直接echo $obj（一个对象）时该显示什么内容，必须返回一个字符串且不能在方法内抛出异常。 __invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用，例如 12345function __invoke($x) &#123; var_dump($x);&#125; $obj = new CallableClass;$obj(5);会输出int(5) __set_state 调用 var_export() 导出类时，此静态 方法会被调用。 本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。 __clone 对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。 对象中的 __clone() 方法不能被直接调用。 $copy_of_object = clone $object; 当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。当复制完成时，如果定义了 clone() 方法，则新创建的对象（复制生成的对象）中的 clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 __debugInfo 当var_dumo(new Class)（参数为一个对象时），该方法可以控制显示的内容，若没有定义此方法，var_dump()将默认展示对象的所有属性和方法。 6.static、$this、self 区别$this通俗解释就是当前类的一个实例。 12345678910111213141516class A &#123; public static function className() &#123; echo __CLASS__; &#125; public static function test() &#123; self::className(); &#125;&#125;class B extends A &#123; public static function className()&#123; echo __CLASS__; &#125;&#125;B::test(); //这将打印出来A 另一方面static::它具有预期的行为 1234567891011121314151617class A &#123; public static function className() &#123; echo __CLASS__; &#125; public static function test() &#123; static::className(); &#125;&#125;class B extends A &#123; public static function className() &#123; echo __CLASS__; &#125;&#125;B::test(); // 这将打印出来B 这在PHP 5.3.0中称为后期静态绑定。它解决了调用运行时引用的类的限制。 7.private、protected、public、final 区别public:权限是最大的，可以内部调用，实例调用等。 protected: 受保护类型，用于本类和继承此类的子类调用。 private: 私有类型，只有在本类中使用。 static：静态资源，可以被子类继承。 abstract：修饰抽象方法，没有方法体，由继承该类的子类来实现。 final：表示该变量、该方法已经“完成”，不可被覆盖。修饰类时该类不能被继承。 （因此final和abstract不能同时出现） 8.OOP思想简单理解： 面向对象的编程就是编出一个人来，这个人可以做很多种动作，跑，跳，走，举手…他能做什么取决于你如何组合这些动作，有些动作在一些功能中是不用的。 而层次化的编程（面向过程）就是造出一个具体的工具，他只能干这样一件事，条件——结果。 9.抽象类、接口 分别使用场景接口 通常是为了抽象一种行为，接口是一种规范，在设计上的意义是为了功能模块间的解耦，方便后面的功能扩展、维护，接口不能有具体的方法。 抽象类 可以有具体的方法，也可以有抽象方法，一旦一个类有抽象方法，这个类就必须声明为抽象类，很多时候是为子类提供一些共用方法。 所以，抽象类是为了简化接口的实现，他不仅提供了公共方法的实现，让你可以快速开发，又允许你的类完全可以自己实现所有的方法，不会出现紧耦合的问题。 应用场合很简单了 1 优先定义接口 2 如果有多个接口实现有公用的部分，则使用抽象类，然后集成它。 举个简单的例子：有一个动物接口，内有动物叫声和动物说你好两个方法，在实现该接口时各个动物的叫声肯定是不同的，但是他们都在说你好是相同的，此时就可以用抽象类，把相同的说你好的方法抽象出去，就不用在每个动物类中写了。 10.Trait 是什么东西Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题。 Trait 和 Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。 无法通过 trait 自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。 简单理解：Trait为不支持多继承的php实现了多继承，使用时不是用extends继承，而是在类内部用 use 类名 表示。 重名方法优先级问题：当前类的成员覆盖 trait 的方法，而 trait 则覆盖被继承的方法。","categories":[{"name":"php基础","slug":"php基础","permalink":"http://yoursite.com/categories/php基础/"},{"name":"php常识","slug":"php基础/php常识","permalink":"http://yoursite.com/categories/php基础/php常识/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php常用函数","slug":"php常用函数","date":"2016-07-05T16:00:00.000Z","updated":"2019-02-24T14:00:05.432Z","comments":true,"path":"2016/07/06/php常用函数/","link":"","permalink":"http://yoursite.com/2016/07/06/php常用函数/","excerpt":"","text":"php常用函数1.数组函数 array_chunk // 将一个数组分割成多个 array_column // 返回数组中指定的一列 array_combine // 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值（另一种意义的合并数组） array_flip // 交换数组中的键和值 array_key_exists // 检查数组里是否有指定的键名或索引 array_key_first // 返回数组第一个键的键名 array_key_last // 返回数组最后一个键的键名 array_keys // 返回数组键名 array_merge // 合并一个或多个数组 array_pop // 弹出数组最后一个单元；出栈；删除数组最后一个单元 array_push // 将一个或多个单元压入数组的末尾；入栈；合并数组 array_rand // 从数组中随机取出一个或多个单元 array_reverse // 返回单元顺序相反的数组 array_search // 在数组中搜索给定的值，如果成功则返回首个相应的键名 array_shift // 将数组开头的单元移出数组 array_slice // 从数组中取出一段 array_sum // 对数组中所有值求和 array_unique // 移除数组中重复的值 array_unshift // 在数组开头插入一个或多个单元 array_values // 返回数组中所有的值 arsort // 对数组进行逆向排序并保持索引关系 asort // 对数组进行排序并保持索引关系 count // 计算数组中的单元数目，或对象中的属性个数 current // 返回数组中的当前单元 in_array // 检查数组中是否存在某个值 krsort // 对数组按照键名逆向排序 ksort // 对数组按照键名排序 list // 把数组中的值赋给一组变量 shuffle // 打乱数组 sort // 对数组排序 uasort // 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 uksort // 使用用户自定义的比较函数对数组中的键名进行排序 usort // 使用用户自定义的比较函数对数组中的值进行排序 2.string(字符串)函数 chunk_split // 将字符串分割成小块 explode // 使用一个字符串分割另一个字符串 implode // 将一个一维数组的值转化为字符串 lcfirst // 使一个字符串的第一个字符小写 ltrim // 删除字符串开头的空白字符（或其他字符） md5 // 计算字符串的 MD5 散列值 money_format // 将数字格式化成货币字符串 nl2br // 在字符串所有新行之前插入 HTML 换行标记 number_format // 以千位分隔符方式格式化一个数字 ord // 返回字符的 ASCII 码值 rtrim // 删除字符串末端的空白字符（或者其他字符） str_replace // 子字符串替换 str_ireplace // str_replace 的忽略大小写版本 str_repeat // 重复一个字符串 str_shuffle // 随机打乱一个字符串 str_split // 将字符串转换为数组 stripos // 查找字符串首次出现的位置（不区分大小写） strpos // 查找字符串首次出现的位置 strstr // 查找字符串的首次出现 stristr // strstr 函数的忽略大小写版本 strlen // 获取字符串长度 strrchr // 查找指定字符在字符串中的最后一次出现 strrev // 反转字符串 strripos // 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写） strrpos // 计算指定字符串在目标字符串中最后一次出现的位置 strtok // 标记分割字符串 strtolower // 将字符串转化为小写 strtoupper // 将字符串转化为大写 substr_count // 计算字串出现的次数 substr_replace // 替换字符串的子串 substr // 返回字符串的子串 trim // 去除字符串首尾处的空白字符（或者其他字符） ucfirst // 将字符串的首字母转换为大写 ucwords // 将字符串中每个单词的首字母转换为大写 wordwrap // 打断字符串为指定数量的字串 3.普通字符串处理函数和mb_系列函数的区别：不同编码的个别语言（比如中文）所占字节数不同，一个汉字在GB2312编码下占2个字节，在UTF-8（是变长编码）编码下占2-3个字节，普通字符串处理函数是按每个字符1字节来处理的，而mb_系列的函数在使用时可以多指定一个编码参数，方便处理不同编码的中文。 最简单的例子，strlen() 会返回一个字符串所占字节数，而mb_strlen()会返回一个字符串的字符数。再比如，substr($str2, 2, 2)在$str为中文时可能会正好截取到一个汉字的一部分，这时就会发生乱码，而mb_substr($str, 2, 2, ‘utf-8’)指定编码后就不会发生乱码问题了，中文时即是取几个汉字。","categories":[{"name":"php基础","slug":"php基础","permalink":"http://yoursite.com/categories/php基础/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"名词备忘","slug":"名词备忘","date":"2016-07-04T16:00:00.000Z","updated":"2019-01-27T21:23:48.500Z","comments":true,"path":"2016/07/05/名词备忘/","link":"","permalink":"http://yoursite.com/2016/07/05/名词备忘/","excerpt":"","text":"12345678910111213数组 = 数组 = 集合数列 = 规则数组函数F(x)的F只是名字值域 = 函数值范围定义域 = x取值范围键名 key值 value索引数组中的单元数目出栈入栈对象中的属性个数迭代 = 循环","categories":[{"name":"通用","slug":"通用","permalink":"http://yoursite.com/categories/通用/"}],"tags":[{"name":"通用","slug":"通用","permalink":"http://yoursite.com/tags/通用/"}]},{"title":"hexo使用步骤","slug":"hexo使用步骤","date":"2016-07-03T16:00:00.000Z","updated":"2019-01-27T20:07:53.299Z","comments":true,"path":"2016/07/04/hexo使用步骤/","link":"","permalink":"http://yoursite.com/2016/07/04/hexo使用步骤/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}