<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UI设计]]></title>
    <url>%2F2019%2F07%2F01%2FUI%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[UIUI(User Interface) 既用户界面，UI设计师指对软件的人际交互，操作逻辑、界面美观性的整体设计。 UI大体3部分图形用户界面（Graphical User Interface）是指采用图形方式显示的用户操作界面，图形用户界面对于用户来说，在完美视觉效果上感觉十分明显，它通过图形界面向用户展示功能、模块、媒体等信息。 交互设计（Interaction Design）交互设计用于定义人造物的行为方式（人工制品在特定场景下的反应方式）相关的界面。交互设计的出发点在于研究人在与物交流的过程中，人的心理模式和行为模式，并在此基础上，设计出可提供的交互方式，以满足人对试用人工物的需求。交互设计是设计方法，而界面设计师交互设计的自然结果。交互设计师首先进行用户研究，分析相关领域以及潜在用户，设计人造物的行为，并从有用、可用及易用性等方面来评估设计质量。 用户研究（User Study）测试交互设计的合理性以及图形设计的美观性。 界面设计常用单位英寸长度单位，表示从电脑的屏幕到电视机再到各类多媒体设备的屏幕大小，通常指屏幕的对角长度。 分辨率即屏幕物理像素的总和，用屏幕宽乘以屏幕高的像素数来表示。 网点密度即屏幕物理面积内所包含的像素数，以DPI（每英寸像素点数）为单位来计量，DPI越高，显示的画面质量就越精细。在手机UI设计中，DPI要与手机相匹配，因为低分辨率的手机无法满足高DPI图片对手机硬件的要求，显示效果会十分糟糕，所以在设计过程中就涉及到一个全新的名词”屏幕密度”。 屏幕密度以搭载ANDroid手机为例，分别如下。iDPI（低密度）：120像素/英寸mDPI（中密度）：160像素/英寸hDPI（高密度）：240像素/英寸xhDPI（超高密度）：320像素/英寸与Android相比，iPhone手机对密度版本的数量要求没那么多，因为目前iPhone界面仅两种设计尺寸”960640(px)”和”6401136(px)”，而网点密度（DPI）采用mDPI，即160像素/英寸就可以满足设计要求。 界面设计准则1.简易型2.一致性3.提升用户的熟知度4.可控性5.记忆负担最小化6.从用户的角度考虑7.顺序性8.安全性9.灵活性界面设计与团队合作关系1.团队成员产品经理：对于用户需求进行分析调研，针对不同的需求进行产品卖点规划，然后将规划的结果陈述给公司上级，以此来取得项目所要用到的各类资源（人力、物力、和财力等）。产品设计师：产品设计师侧重功能设计，考虑技术可行性，比如在设计一款特殊播放器时候考虑是否在播放的过程中添加动画提示甚至一些更复杂的功能，而这些功能的添加都是经过深思熟虑的。用户体验工程师：用户体验工程师需要了解更多商业层面的内容，其工作通常与产品设计师相辅相成，从产品商业价值的角度出发，以用户的切身体验实际感觉出发，对产品与用户交互上的环节进行设计上的改良。图形界面设计师：图形界面设计师为应用设计一款能适应用户需求的界面，一款应用能否成功，与图形界面设计也有着分不开的关系。 2.UI设计与项目流程步骤产品定位-&gt;产品风格-&gt;产品控件-&gt;方案制订-&gt;方案提交-&gt;方案选定]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F01%2F20%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[php中常用的正则表达式函数1234567891011121314151617181920$pattern = 正则表达式$subject = 匹配的目标数据preg_match($pattern, $subject) // 匹配$subject一次，$subject输出为1维数组，return匹配到结果的次数// 使用场景 - 表单验证等preg_match_all($pattern, $subject, array &amp;$matches) // $subject字符串中所有符合$pattern的结果都匹配出来，$subject输出为2维数组，return匹配到结果的次数preg_replace($pattern, $replacement, $subject) // 返回全部，$replacement数组里的值不发生匹配替换的也返回。// 使用场景 - 非法词语过滤等preg_filter($pattern, $replacement, $subject) // 返回匹配替换的preg_grep($pattern, array $input) // 返回匹配的值preg_split($pattern, $subject) // 返回匹配到的就分割为一个数组preg_quote($str) // 正则运算符转义，匹配到的前面都加上\ 正则表达式基本语法界定符表示一个正则表达式的开始和结束/包含住正则语法/1$pattern = &apos;/[0-9]/&apos;; 也可以这么写12#[0-9]#&#123;[0-9]&#125; 原子可见原子 - unicode编码表中用键盘输出后肉眼可见的字符不可见原子 - unicode编码表中用键盘输出后肉眼不可见的字符，如\n,\r,\t,空格等。 原子的元字符原子的筛选方式| 匹配两个或者多个分支选择[] 匹配方括号中的任意一个原子，支持区间匹配用-来连接。[^] 匹配除方括号中的原子之外的任意字符 原子的集合. 匹配除换行符之外的任意字符\d 匹配任意一个十进制数字，即[0-9]\D 匹配任意一个非十进制数字，即[^0-9]\s 匹配一个不可见原子，即[\f\n\r\t\v]\S 匹配一个可见原子，即[^\f\n\r\t\v]\w 匹配任意一个数字、字母或下划线，即[0-9a-zA-Z_]\W 匹配任意一个非数字、字母或下划线，即[^0-9a-zA-Z_] 量词{n} 表示其前面的原子恰好出现n次{n,} 表示其前面的原子最少出现n次{n,m} 表示其前面的原子最少出现n此，最多出现m次 匹配0次、1次或者多次其之前的原子，即{0,} 匹配1次或者多次其之前的原子，即{1,}? 匹配0次或者1次其之前的原子，即{0,1} 边界控制^ 匹配字符串开始的位置$ 匹配字符串结尾的位置 模式单元() 匹配其中的整体为一个原子 修正模式用法：界定符后 + 修正模式u贪婪匹配 - 匹配结果存在歧义时取其长，默认U懒惰匹配 - 匹配结果存在歧义时取其短，用法：界定符后+Ui - 忽略英文字母大小写x - 忽略空白符s - 让元字符’ . ‘匹配包括换行符在内所有字符e - 实战非空匹配1$pattern = &apos;/.+/&apos;; 浮点数匹配1$pattern = &apos;/\d+\.\d&#123;2&#125;$/&apos;; 手机号匹配1$pattern = &apos;/1(3|4|5|6|7|8)\d&#123;10&#125;/&apos;; 邮箱匹配1$pattern = &apos;/^\w+(\.\w)*@\w+(\.\w+)+$/&apos;; 域名匹配1$pattern = &apos;/^(https?://)?\w+\.)+[a-zA-Z]+$/&apos;;]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php实践]]></title>
    <url>%2F2016%2F09%2F01%2Fphp%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[1.给定二维数组，根据某个字段排序一组学生信息，要按年龄大小升序或降序排序（类似与sql语句的order by功能）123456$arr = [ [&apos;id&apos; =&gt; 6, &apos;name&apos; =&gt; &apos;小明&apos;], [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;小亮&apos;], [&apos;id&apos; =&gt; 13, &apos;name&apos; =&gt; &apos;小红&apos;], [&apos;id&apos; =&gt; 2, &apos;name&apos; =&gt; &apos;小强&apos;],]; 答：12345678910111213141516171819202122232425262728// 方法1：手动写排序方法：/** 对给定二维数组按照某个字段升序或降序排序 * @param $arr 给定一个二维数组，这里的$arr * @param $sortField 根据哪个字段排序，这里的id * @param string $sort 升序还是降序,默认升序 * 思路：取出所有要排序的字段的值组成一个新数组，根据升序降序保留键值排序，此时新数组的键值顺序就是要得到的排序后的二维数组的键值顺序，然后将原二维数组按照此键值顺序排列即可。 * 注意：这里没有重置排序后的二维数组的索引，如需重置可自行扩展 */private function arraySort($arr, $sortField, $sort = &apos;asc&apos;) &#123; $newArr = array(); foreach ($arr as $key =&gt; $value) &#123; $newArr[$key] = $value[$sortField]; &#125; ($sort == &apos;asc&apos;) ? asort($newArr) : arsort($newArr); foreach ($newArr as $k =&gt; $v) &#123; $newArr[$k] = $arr[$k]; &#125; return $newArr;&#125;// 方法2：使用php提供的排序函数array_multisort（），默认会重置排序后的索引，即从0开始顺序往下排foreach ($arr as $key =&gt; $value) &#123; $id[$key] = $value[&apos;id&apos;];&#125;array_multisort($id, SORT_ASC, $arr); // 返回True or False 2.如何判断上传文件类型，如：仅允许 jpg 上传网上出现频率较高的一段代码：lz认为此段代码对上传文件的类型限制还是比较好的，因为之前看资料说仅通过mime类型判断有时候不太靠谱，而仅通过文件后缀名判断好像也不是很靠谱，所以这里采用双重判断，以下代码稍微加了点注释： 1234567891011121314151617181920212223242526&lt;?php$allowedExts = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;); // 限定可上传的文件后缀名$extension = end(explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;])); // 从文件名中获取文件后缀名// 判断上传文件mime类型是下列之一且大小小于20000B且文件后缀名也符合要求if (( ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/x-png&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/png&quot;)) &amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 20000) &amp;&amp; in_array($extension, $allowedExts)) &#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) &#123; echo &quot;Return Code: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;; &#125; else &#123; echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; kB&lt;br&gt;&quot;; echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] . &quot;&lt;br&gt;&quot;; //临时文件名 &#125; if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])) &#123; // 同名文件已存在时提示文件已存在 echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;; &#125; else &#123; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;Stored in: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125;?&gt; 3.不使用临时变量交换两个变量的值 $a=1; $b=2; =&gt; $a=2; $b=1;最先想到的利用加减运算这里就不说了，因为那只适用于数字类型。 123456789101112131415// 1.字符串截取法：function myExchange(&amp;$a = &apos;&apos;, &amp;$b = &apos;&apos;) &#123; $a = $a . $b; $b = substr($a,0,-strlen($b)); $a = substr($a,strlen($a)-strlen($b),strlen($b)); return true;&#125;// 2.数组法： private function myExchange(&amp;$a = &apos;&apos;, &amp;$b = &apos;&apos;) &#123; $a = array($a, $b); $b = $a[0]; $a = $a[1]; return true;&#125; 4.strtoupper 在转换中文时存在乱码，你如何解决？php echo strtoupper(‘ab你好c’);php echo strtoupper(‘ab你好c’);（经测试中文系统下不会出现乱码，网上资料说是英文系统或部分盗版系统或因编码格式问题可能出现题述情况。 12345678910111213141516171819202122232425262728293031// 1.mb系列函数解决（mb系列函数可以显式指明编码）string mb_convert_case (string $str ,int $mode [,string $encoding = mb_internal_encoding()])$mode有三种模式： 1.MB_CASE_UPPER：转成大写 2.MB_CASE_LOWER：转成小写 3.MB_CASE_TITLE ：转成首字母大写$encoding默认使用内部编码；也可以显示使用如’UTF-8’; 可以用echo mb_internal_encoding();来查看；此方法不仅可以解决中文问题，对其他问题也适用。2.手动解决：用str_split(string $string, int $split_length = 1)按每个字节切割，像中文能切割成三个字节。对识别到的字节若是英文字母则进行转换。&lt;?phpfunction mystrtoupper($a)&#123; $b = str_split($a, 1); $r = &apos;&apos;; foreach($b as $v)&#123; $v = ord($v);//对该字符转成acsii码 if($v &gt;= 97 &amp;&amp; $v&lt;= 122)&#123;//判断是否为小写字母 $v -= 32;//转换成大写字母 &#125; $r .= chr($v);//将ascii码再转为相应的字符。 &#125; return $r;&#125;$a = &apos;a中你继续F@#$%^&amp;*(BMDJFDoalsdkfjasl&apos;;echo &apos;origin string:&apos;.$a.&quot;\n&quot;;echo &apos;result string:&apos;;$r = mystrtoupper($a);var_dump($r); 5.Websocket、Long-Polling、Server-Sent Events(SSE) 区别Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE 6.”Headers already sent” 错误是什么意思，如何避免StackOverflow原文链接 错误说明：“不能更改头信息-头已经发出”；意思大概是在你的代码中有修改header信息的代码段，但是在此代码段之前header已经发出，所以报错不能修改。 如何避免：在发送header前不能有任何输出，会发送header的部分方法： header / header_removesession_start / session_regenerate_idsetcookie / setrawcookie类似于输出功能的操作（不能放在header相关处理之前）： 无意的：&lt;?php之前或?&gt;之后的空格UTF-8编码的BOM头信息以前的错误消息或通知 故意的： print，echo等产生输出的输出Raw sections prior &lt;?php code.（抱歉没有看懂）]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php算法]]></title>
    <url>%2F2016%2F09%2F01%2Fphp%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.冒泡排序1234567891011121314function maopao($arr) &#123; $len = count($arr); $n = count($arr) - 1; for ($i = 0; $i &lt; $len; $i++) &#123; for ($j = 0; $j &lt; $n; $j++) &#123; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j]; $arr[$j] = $arr[$j + 1]; $arr[$j + 1] = $tmp; &#125; &#125; &#125; return $arr;&#125; 2.快速排序123456789101112131415function quick_sort($array) &#123; if (count($array) &lt;= 1) return $array; $key = $array[0]; $left_arr = array(); $right_arr = array(); for ($i=1; $i&lt;count($array); $i++)&#123; if ($array[$i] &lt;= $key) $left_arr[] = $array[$i]; else $right_arr[] = $array[$i]; &#125; $left_arr = quick_sort($left_arr); $right_arr = quick_sort($right_arr); return array_merge($left_arr, array($key), $right_arr);&#125; 3.二分查找php二分查找、顺序查找算法 4.查找算法 KMP从头到尾彻底理解KMP 5.深度、广度优先搜索DFS（深度优先搜索）和BFS(广度优先搜索)图的广度优先和深度优先遍历（BFS和DFS）二叉树的深度优先遍历与广度优先遍历 [ C++ 实现 ]PHP 二叉树的深度优先与广度优先遍历 6.LRU 缓存淘汰算法LRU算法(php实现)]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2016%2F09%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.堆、栈特性栈：像装数据的桶或箱子我们先从大家比较熟悉的栈说起吧，它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。 这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我们首先要移开压在它上面的物体（放入的比较晚的物体）。 百度百科：栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。 堆：像一棵倒过来的树而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。 通常我们所说的堆的数据结构，是指二叉堆。 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。 由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。 百度百科：堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 堆和栈的区别可以引用一位前辈的比喻来看出：使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。比喻很形象，说的很通俗易懂，不知道你是否有点收获。 2.队列队列（queue）是一种采用先进先出(FIFO)策略的抽象数据结构，它的想法来自于生活中排队的策略。顾客在付款结账的时候，按照到来的先后顺序排队结账，先来的顾客先结账，后来的顾客后结账。队列的实现一般有数组实现和链表实现两种方式。队列又分单链队列、循环队列、阵列队列，具体可参见维基 3.哈希表Hash表也称散列表，也有直接译作哈希表，Hash表是一种特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，通过把关键码值（Key value）映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做Hash函数，存放记录的数组叫做Hash表。 4.链表链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php知识点]]></title>
    <url>%2F2016%2F07%2F20%2Fphp%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.普通字符串处理函数和mb_系列函数的区别：不同编码的个别语言（比如中文）所占字节数不同，一个汉字在GB2312编码下占2个字节，在UTF-8（是变长编码）编码下占2-3个字节，普通字符串处理函数是按每个字符1字节来处理的，而mb_系列的函数在使用时可以多指定一个编码参数，方便处理不同编码的中文。最简单的例子，strlen() 会返回一个字符串所占字节数，而mb_strlen()会返回一个字符串的字符数。再比如，substr($str2, 2, 2)在$str为中文时可能会正好截取到一个汉字的一部分，这时就会发生乱码，而mb_substr($str, 2, 2, ‘utf-8’)指定编码后就不会发生乱码问题了，中文时即是取几个汉字。 2.&amp; 引用，结合案例分析PHP 的引用允许用两个变量来指向同一个内容。 1$a = &amp; $b; $a 和 $b 在这里是完全相同的，这并不是 $a 指向了 $b 或者相反，而是 $a 和 $b 指向了同一个地方。 引用做的第二件事是用引用传递变量。 12345function foo(&amp; $var) &#123; $var++;&#125;$a = 5;foo($a); 将使 $a 变成 6。这是因为在 foo 函数中变量 $var 指向了和 $a 指向的同一个内容。 引用不是指针，下面的结构不会产生预期的效果： 12345function foo(&amp; $var) &#123; $var = &amp; $GLOBALS[&quot;baz&quot;];&#125;foo($bar); 当 unset 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了。例如： 123$a = 1;$b =&amp; $a;unset($a); 不会 unset $b，只是 $a。 3.== 与 === 区别== 是不带类型比较是否相同（比如数字100 == ‘100’结果为true） === 是带类型比较是否相同（比如100 == ‘100’结果为false） 4.isset 与 empty 区别empty()empty()：如果变量是非空或非零的值，则返回false。 “”、0、”0”、NULL、FALSE、array()、var $var、未定义，没有任何属性的对象，则返回false。 如果var为空，则返回true。 isset()isset()：如果变量存在（非null）则返回true，否则返回false。 变量值设置为：null，返回也是false; unset一个变量后，变量被取消了。注意，isset对于NULL值变量，特殊处理。 is_null()is_null()：检测传入值【值，变量，表达式】是否是null。只有一个变量定义了，且它的值是null，它才返回TRUE。其它都返回 FALSE 【未定义变量传入后会出错！】。 defined()defined()：检测一个常量是否已经定义 property_exists()property_exists()：检测一个类(或对象)中是否存在某一个属性，跟array_key_exists()一样，即使属性值为null，仍然返回true。 5.全部魔术函数理解1. __construct类的构造函数，常用来给类的属性赋值。 注意事项：如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()，如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。 2. __destruct析构函数，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 3. call，callStatic在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用，作为调用类中不存在的方法时对开发者的一个友好提示。 4. set，get，isset ，unset在给不可访问属性赋值时，__set() 会被调用； 读取不可访问属性的值时，__get() 会被调用； 当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用； 当对不可访问属性调用 unset() 时，__unset() 会被调用。 5. sleep，wakeup serialize()函数会检查类中是否存在一个魔术方法 __sleep()。 如果存在，该方法会先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误，返回父类的私有成员的名字，常用于提交未提交的数据，或类似的清理操作。 与之相反，unserialize() 会检查是否存在一个 wakeup() 方法。如果存在，则会先调用 wakeup 方法，预先准备对象需要的资源。__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 6. __toString用于当直接echo $obj（一个对象）时该显示什么内容，必须返回一个字符串且不能在方法内抛出异常。 7. __invoke当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用，例如 12345function __invoke($x) &#123; var_dump($x);&#125; $obj = new CallableClass;$obj(5);会输出int(5) 8. __set_state调用 var_export() 导出类时，此静态 方法会被调用。 本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。 9. __clone对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。 对象中的 __clone() 方法不能被直接调用。 10. $copy_of_object = clone $object;当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。当复制完成时，如果定义了 clone() 方法，则新创建的对象（复制生成的对象）中的 clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 11. __debugInfo当var_dumo(new Class)（参数为一个对象时），该方法可以控制显示的内容，若没有定义此方法，var_dump()将默认展示对象的所有属性和方法。 6.static、$this、self 区别$this通俗解释就是当前类的一个实例。 12345678910111213141516class A &#123; public static function className() &#123; echo __CLASS__; &#125; public static function test() &#123; self::className(); &#125;&#125;class B extends A &#123; public static function className()&#123; echo __CLASS__; &#125;&#125;B::test(); //这将打印出来A 另一方面static::它具有预期的行为 1234567891011121314151617class A &#123; public static function className() &#123; echo __CLASS__; &#125; public static function test() &#123; static::className(); &#125;&#125;class B extends A &#123; public static function className() &#123; echo __CLASS__; &#125;&#125;B::test(); // 这将打印出来B 这在PHP 5.3.0中称为后期静态绑定。它解决了调用运行时引用的类的限制。 7.private、protected、public、final 区别public:权限是最大的，可以内部调用，实例调用等。 protected: 受保护类型，用于本类和继承此类的子类调用。 private: 私有类型，只有在本类中使用。 static：静态资源，可以被子类继承。 abstract：修饰抽象方法，没有方法体，由继承该类的子类来实现。 final：表示该变量、该方法已经“完成”，不可被覆盖。修饰类时该类不能被继承。 （因此final和abstract不能同时出现） 8.OOP思想简单理解： 面向对象的编程就是编出一个人来，这个人可以做很多种动作，跑，跳，走，举手…他能做什么取决于你如何组合这些动作，有些动作在一些功能中是不用的。 而层次化的编程（面向过程）就是造出一个具体的工具，他只能干这样一件事，条件——结果。 9.抽象类、接口 分别使用场景接口 通常是为了抽象一种行为，接口是一种规范，在设计上的意义是为了功能模块间的解耦，方便后面的功能扩展、维护，接口不能有具体的方法。 抽象类 可以有具体的方法，也可以有抽象方法，一旦一个类有抽象方法，这个类就必须声明为抽象类，很多时候是为子类提供一些共用方法。 所以，抽象类是为了简化接口的实现，他不仅提供了公共方法的实现，让你可以快速开发，又允许你的类完全可以自己实现所有的方法，不会出现紧耦合的问题。 应用场合很简单了 1 优先定义接口 2 如果有多个接口实现有公用的部分，则使用抽象类，然后集成它。 举个简单的例子：有一个动物接口，内有动物叫声和动物说你好两个方法，在实现该接口时各个动物的叫声肯定是不同的，但是他们都在说你好是相同的，此时就可以用抽象类，把相同的说你好的方法抽象出去，就不用在每个动物类中写了。 10.Trait 是什么东西Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。 Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。 Trait 和 Class 组合的语义定义了一种减少复杂性的方式， 避免传统多继承和 Mixin 类相关典型问题。 Trait 和 Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。无法通过 trait 自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。 简单理解：Trait为不支持多继承的php实现了多继承，使用时不是用extends继承，而是在类内部用 use 类名 表示。 重名方法优先级问题：当前类的成员覆盖 trait 的方法，而 trait 则覆盖被继承的方法。 11.echo、print、print_r 区别(区分出表达式与语句的区别)：echo，print是语言结构，print_r和var_dump是常规功能。 print并且echo或多或少相同; 它们都是显示字符串的语言结构。差异很微妙：print返回值为1，因此可以在表达式中使用，但echo具有void返回类型。echo可以采用多个参数，尽管这种用法很少见;echo比print快一点。（就个人而言，我总是使用echo，从不print。） var_dump打印出变量的详细转储，包括其类型大小和任何子项的类型和大小（如果它是数组或对象）。 print_r以更易于阅读的格式化形式打印变量（数组或对象）：不能传递字符串，它省略了类型信息，不给出数组大小等。 var_dump， print_r根据我的经验，通常在调试时更有用。当您不确切知道变量中的值/类型时，它尤其有用。考虑这个测试程序： 1234567891011121314151617181920212223242526272829$values = array(0, 0.0, false, &apos;&apos;);var_dump($values);print_r ($values);随着print_r你不能告诉之间的区别0和0.0，或false和&apos;&apos;：array(4) &#123; [0]=&gt; int(0) [1]=&gt; float(0) [2]=&gt; bool(false) [3]=&gt; string(0) &quot;&quot;&#125;Array( [0] =&gt; 0 [1] =&gt; 0 [2] =&gt; [3] =&gt; ) 12.construct 与 destruct 区别在一个类中定义一个方法作为构造函数。 具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 和构造函数一样，父类的析构函数不会被引擎暗中调用。 要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct()。 此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。 析构函数即使在使用 exit() 终止脚本运行时也会被调用。 在析构函数中调用 exit() 将会中止其余关闭操作的运行。 13.static 作用（区分类与函数内）手册 、SOF声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。为了兼容 PHP 4，如果没有指定访问控制，属性和方法默认为公有。由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。静态属性不可以由对象通过 -&gt; 操作符来访问，但可以由对象通过 :: 来访问用静态方式调用一个非静态方法会导致一个 E_STRICT 级别的错误。就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。也可以用一个值等于类名的字符串变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static，比如有个class A{}， 则可以用$a=’A’; $a::这样调用在类之外（即：在函数中），static变量是在函数退出时不会丢失其值的变量。在同一函数的不同调用中维护的变量只有一个值。从PHP手册的例子： 12345678910111213function test()&#123; static $a = 0; echo $a; $a++;&#125;test(); // prints 0test(); // prints 1test(); // prints 2 14.__toString() 作用用于一个类被当成字符串时应怎样回应。 例如 echo $obj; （$obj为一个对象） 应该显示些什么。 此方法必须返回一个字符串，否则将发出一条E_RECOVERABLE_ERROR 级别的致命错误。 类似与Java的toString方法。 15.单引号’与双引号”区别单引号字符串几乎完全“按原样”显示。变量和大多数转义序列都不会被解释。例外情况是，要显示单引号字符，必须使用反斜杠\’转义它，要显示反斜杠字符，必须使用另一个反斜杠转义它\。 双引号字符串将显示一系列转义字符（包括一些正则表达式），并且将解析字符串中的变量。这里重要的一点是，您可以使用花括号来隔离要解析的变量的名称。例如，假设您有变量$type，那么您echo “The $type are”将查找该变量$type。绕过这个用途echo “The {$type} are”您可以在美元符号之前或之后放置左括号。看一下字符串解析，看看如何使用数组变量等。 Heredoc字符串语法就像双引号字符串一样。它始于&lt;&lt;&lt;。在此运算符之后，提供标识符，然后提供换行符。字符串本身如下，然后再次使用相同的标识符来关闭引号。您不需要在此语法中转义引号。 Nowdoc（自PHP 5.3.0开始）字符串语法基本上类似于单引号字符串。不同之处在于，甚至不需要转义单引号或反斜杠。nowdoc用与heredocs相同的&lt;&lt;&lt;序列标识，但后面的标识符用单引号括起来，例如&lt;&lt;&lt;’EOT’。在nowdoc中没有解析。 16.常见 HTTP 状态码，分别代表什么含义，301 什么意思 404 呢?1xx消息：这一类型的状态码，代表请求已被接受，需要继续处理。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。2xx成功：这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。200 OK：请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。202 Accepted：服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。204 No Content：服务器成功处理了请求，没有返回任何内容。3xx重定向：这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。301 Moved Permanently：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。4xx客户端错误：这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。400 Bad Request：由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。401 Unauthorized：类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。[32]该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。403 Forbidden：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。[35]没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。405 Method Not Allowed：请求行中指定的请求方法不能被用于请求相应的资源。408 Request Timeout：请求超时。5xx服务器错误：表示服务器无法完成明显有效的请求。[56]这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。500 Internal Server Error：通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。503 Service Unavailable：由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。504 Gateway Timeout：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器在DNS查询超时时会返回400或者500错误。 17.__autoload、composer 原理 PSR-4 、原理autoload机制可以使得PHP程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为lazy loading(懒加载)。 12345678910111213141516171819function __autoload($classname)&#123; $classpath=&quot;./&quot;.$classname.&apos;.class.php&apos;; if(file_exists($classpath)) &#123; require_once($classpath); &#125; else &#123; echo &apos;class file&apos;.$classpath.&apos;not found!&apos;; &#125;&#125; $person = new Person(”Altair”, 6); var_dump ($person); 通常PHP在使用一个类时，如果发现这个类没有加载，就会自动运行__autoload()函数，在这个函数中我们可以加载需要使用的类。 autoload()至少要做三件事，1：根据类名确定类文件名。2：确定类文件所在的磁盘路径(类与调用它们的PHP程序文件在同一个文件夹下)。3：将类从磁盘文件中加载到系统中(php7.2废除autoload函数，建议使用spl_autoload_register() 实现相同功能) Autoload原理简单概述：1：检查执行器全局变量函数指针autoload_func是否为NULL。2：如果autoload_func==NULL, 则查找系统中是否定义有autoload()函数，如果没有，则报告错误并退出。3：如果定义了autoload()函数，则执行autoload()尝试加载类，并返回加载结果。4：如果autoload_func不为NULL，则直接执行autoload_func指针指向的函数用来加载类。注意此时并不检查autoload()函数是否定义。 spl_autoload_register()就是我们上面所说的__autoload调用堆栈，我们可以向这个函数注册多个我们自己的 autoload() 函数，当 PHP 找不到类名时，PHP就会调用这个堆栈，然后去调用自定义的 autoload() 函数，实现自动加载功能。如果我们不向这个函数输入任何参数，那么就会默认注册 spl_autoload() 函数。 composer 做了哪些事情：你有一个项目依赖于若干个库；其中一些库依赖于其他库；你声明你所依赖的东西；composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。 执行 composer require 时发生了什么：composer 会找到符合 PR4 规范的第三方库的源；将其加载到 vendor 目录下；初始化顶级域名的映射并写入到指定的文件里；写好一个 autoload 函数，并且注册到 spl_autoload_register()里。 composer是利用的遵循psr-4规范的类自动加载机制实现的，PSR-4规范简介：1:完整的类名 必须 要有一个顶级命名空间，被称为 “vendor namespace”；2:完整的类名 可以 有一个或多个子命名空间；3:完整的类名 必须 有一个最终的类名；4:完整的类名 中任意一部分中的下滑线都是没有特殊含义的；5:完整的类名 可以 由任意大小写字母组成；6:所有类名都 必须 是大小写敏感的。7:完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为「命名空间前缀」，其必须与至少一个「文件基目录」相对应；8:紧接命名空间前缀后的子命名空间 必须 与相应的「文件基目录」相匹配，其中的命名空间分隔符将作为目录分隔符。9:末尾的类名 必须 与对应的以 .php 为后缀的文件同名。10:自动加载器（autoloader）的实现 一定不可 抛出异常、一定不可 触发任一级别的错误信息以及 不应该 有返回值。 composer自动加载原理概述：如果我们在代码中写下 new phpDocumentor\Reflection\Element()，PHP 会通过 SPL_autoload_register 调用 loadClass -&gt; findFile -&gt; findFileWithExtension。步骤如下： 将 \ 转为文件分隔符/，加上后缀php，变成 $logicalPathPsr4, 即 phpDocumentor/Reflection//Element.php;利用命名空间第一个字母p作为前缀索引搜索 prefixLengthsPsr4 数组，查到下面这个数组：12345&apos;p&apos; =&gt; array ( &apos;phpDocumentor\\Reflection\\&apos; =&gt; 25, &apos;phpDocumentor\\Fake\\&apos; =&gt; 19, ) 遍历这个数组，得到两个顶层命名空间 phpDocumentor\Reflection\ 和 phpDocumentor\Fake\ 在这个数组中查找 phpDocumentor\Reflection\Element，找出 phpDocumentor\Reflection\ 这个顶层命名空间并且长度为25。在prefixDirsPsr4 映射数组中得到phpDocumentor\Reflection\ 的目录映射为：123456&apos;phpDocumentor\\Reflection\\&apos; =&gt; array ( 0 =&gt; __DIR__ . &apos;/..&apos; . &apos;/phpdocumentor/reflection-common/src&apos;, 1 =&gt; __DIR__ . &apos;/..&apos; . &apos;/phpdocumentor/type-resolver/src&apos;, 2 =&gt; __DIR__ . &apos;/..&apos; . &apos;/phpdocumentor/reflection-docblock/src&apos;, ) 遍历这个映射数组，得到三个目录映射；查看 “目录+文件分隔符//+substr($logicalPathPsr4, $length)”文件是否存在，存在即返回。这里就是‘DIR/../phpdocumentor/reflection-common/src + substr(phpDocumentor/Reflection/Element.php,25)’如果失败，则利用 fallbackDirsPsr4 数组里面的目录继续判断是否存在文件。 18.session 共享、存活时间为什么要使用Session共享：分布式开发项目中，用户通过浏览器登录商城，实际上会被转发到不同的服务器，当用户登录进入服务器A,session保存了用户的信息，用户再次点击页面被转发到服务器B,这时问题来了，服务器B没有该用户的session信息，无法验证通过，用户被踢回到登录页面，这样体验效果非常不好，甚至无法验证用户，购物车里面商品都不存在了。 利用Redis实现简单的Session共享：1：用户第一次进入商城首页，给一个CSESSIONID,(不用JSESSIONID的原因)，用户添加商品，各种需要记录的操作，都与这个CSESSIONID关联起来；2：当使用登录操作时候，将这个用户的信息，如用户名等存入到redis中，通过K_V，将CSESSIONID加一个标志作为key,将用户信息作为value；3：当用户点击页面被转发到其他服务器时候，在需要验证是否同一个用户时，就可以从redis中取出value,进行验证用户信息，实现共享。 Session 在php配置文件中的默认有效时间是24分钟，设置session永久有效的方法：1：把“session.use_cookies”设置为1，打开Cookie储存SessionID，不过默认就是1，一般不用修改；2：把“session.cookie_lifetime”改为正无穷（当然没有正无穷的参数，不过999999999和正无穷也没有什么区别）;3：把“session.gc_maxlifetime”设置为和“session.cookie_lifetime”一样的时间； 19.异常处理异常处理用于在指定的错误（异常）情况发生时改变脚本的正常流程。这种情况称为异常。 异常的简单使用：抛出一个异常throw new Exception(“Value must be 1 or below”)，同时不去捕获它，服务器会报Fatal error: Uncaught exception ‘Exception’ 的错误； 抛出一个异常throw new Exception(“Value must be 1 or below”)，并try{} catch(Exception $e){echo:’Message:’ . $e-&gt;getMessage();}，当异常发生时，服务器就会报预设的错误提示：Message: Value must be 1 or below。 自定义Exception类：必须继承Exception类，可以使用Exception类的所有方法：12345678class customException extends Exception&#123; public function errorMessage() &#123; //error message $errorMsg = &apos;Error on line &apos;.$this-&gt;getLine().&apos; in &apos;.$this-&gt;getFile().&apos;: &lt;b&gt;&apos;.$this-&gt;getMessage().&apos;&lt;/b&gt; is not a valid E-Mail address&apos;; return $errorMsg; &#125;&#125; 异常的规则：需要进行异常处理的代码应该放入 try 代码块内，以便捕获潜在的异常。 每个 try 或 throw 代码块必须至少拥有一个对应的 catch 代码块。 使用多个 catch 代码块可以捕获不同种类的异常。 可以在 try 代码块内的 catch 代码块中再次抛出（re-thrown）异常。 简而言之：如果抛出了异常，就必须捕获它 20.如何 foreach 迭代对象展示foreach工作原理的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class myIterator implements Iterator &#123; private $position = 0; private $array = array( &quot;firstelement&quot;, &quot;secondelement&quot;, &quot;lastelement&quot;, ); public function __construct() &#123; $this-&gt;position = 0; &#125; //返回到迭代器的第一个元素 function rewind() &#123; var_dump(__METHOD__); $this-&gt;position = 0; &#125; // 返回当前元素 function current() &#123; var_dump(__METHOD__); return $this-&gt;array[$this-&gt;position]; &#125; //返回当前元素的键 function key() &#123; var_dump(__METHOD__); return $this-&gt;position; &#125; //向前移动到下一个元素 function next() &#123; var_dump(__METHOD__); ++$this-&gt;position; &#125; //检查当前位置是否有效 function valid() &#123; var_dump(__METHOD__); return isset($this-&gt;array[$this-&gt;position]); &#125;&#125;$it = new myIterator;foreach($it as $key =&gt; $value) &#123; var_dump($key, $value); echo &quot;\n&quot;;&#125;输出结果：string(18) &quot;myIterator::rewind&quot;string(17) &quot;myIterator::valid&quot;string(19) &quot;myIterator::current&quot;string(15) &quot;myIterator::key&quot;int(0)string(12) &quot;firstelement&quot;string(16) &quot;myIterator::next&quot;string(17) &quot;myIterator::valid&quot;string(19) &quot;myIterator::current&quot;string(15) &quot;myIterator::key&quot;int(1)string(13) &quot;secondelement&quot;string(16) &quot;myIterator::next&quot;string(17) &quot;myIterator::valid&quot;string(19) &quot;myIterator::current&quot;string(15) &quot;myIterator::key&quot;int(2)string(11) &quot;lastelement&quot;string(16) &quot;myIterator::next&quot;string(17) &quot;myIterator::valid&quot; 21.如何数组化操作对象 $obj[key];PHP提供了ArrayAccess接口使实现此接口的类的实例可以向操作数组一样通过$obj[key]来操作，以下是php手册中对实现ArrayAccess接口的类的示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class obj implements arrayaccess &#123; private $container = array(); public function __construct() &#123; $this-&gt;container = array( &quot;one&quot; =&gt; 1, &quot;two&quot; =&gt; 2, &quot;three&quot; =&gt; 3, ); &#125; //设置一个偏移位置的值 public function offsetSet($offset, $value) &#123; if (is_null($offset)) &#123; $this-&gt;container[] = $value; &#125; else &#123; $this-&gt;container[$offset] = $value; &#125; &#125; //检查一个偏移位置是否存在 public function offsetExists($offset) &#123; return isset($this-&gt;container[$offset]); &#125; //复位一个偏移位置的值 public function offsetUnset($offset) &#123; unset($this-&gt;container[$offset]); &#125; //获取一个偏移位置的值 public function offsetGet($offset) &#123; return isset($this-&gt;container[$offset]) ? $this-&gt; container[$offset] : null; &#125;&#125;对该类测试使用：$obj = new obj;var_dump(isset($obj[&quot;two&quot;]));var_dump($obj[&quot;two&quot;]);unset($obj[&quot;two&quot;]);var_dump(isset($obj[&quot;two&quot;]));$obj[&quot;two&quot;] = &quot;A value&quot;;var_dump($obj[&quot;two&quot;]);$obj[] = &apos;Append 1&apos;;$obj[] = &apos;Append 2&apos;;$obj[] = &apos;Append 3&apos;;print_r($obj);?&gt;以上例程的输出类似于：bool(true)int(2)bool(false)string(7) &quot;A value&quot;obj Object( [container:obj:private] =&gt; Array ( [one] =&gt; 1 [three] =&gt; 3 [two] =&gt; A value [0] =&gt; Append 1 [1] =&gt; Append 2 [2] =&gt; Append 3 )) 22.如何函数化对象 $obj(123);利用PHP提供的魔术函数invoke()方法可以直接实现，当尝试以调用函数的方式调用一个对象时， invoke() 方法会被自动调用，下面是官方手册示例：1234567891011121314class CallableClass&#123; function __invoke($x) &#123; var_dump($x); &#125;&#125;$obj = new CallableClass;$obj(5);var_dump(is_callable($obj));输出结果：int(5)bool(true) 23.yield 是什么，说个使用场景 yieldPHP官方手册对yield的解释： 它最简单的调用形式看起来像一个return申明，不同之处在于普通return会返回值并终止函数的执行，而yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数。 我的简单理解：yield起一个暂停程序的作用，比如在一个循环中，程序执行遇到yield语句就会返回yield声明的数据，而不是循环完整体返回，加了yield后就会挨个返回。 Caution：如果在一个表达式上下文(例如在一个赋值表达式的右侧)中使用yield，你必须使用圆括号把yield申明包围起来。 例如这样是有效的：$data = (yield $value); 属于PHP生成器语法，官方手册的解释： 一个生成器函数看起来像一个普通的函数，不同的是普通函数返回一个值，而一个生成器可以yield生成许多它所需要的值。 当一个生成器被调用的时候，它返回一个可以被遍历的对象.当你遍历这个对象的时候(例如通过一个foreach循环)，PHP 将会在每次需要值的时候调用生成器函数，并在产生一个值之后保存生成器的状态，这样它就可以在需要产生下一个值的时候恢复调用状态。 一旦不再需要产生更多的值，生成器函数可以简单退出，而调用生成器的代码还可以继续执行，就像一个数组已经被遍历完了。 Note:一个生成器不可以返回值： 这样做会产生一个编译错误。然而return空是一个有效的语法并且它将会终止生成器继续执行。 使用场景： laravel框架的model以游标方式取数据时，用的是yield来防止一次性取数据太多导致内存不足的问题 PHP 使用协同程序实现合作多任务 24.PSR 是什么，PSR-1, 2, 4, 7PSR-1—基础编码规范 PSR-2—编码风格规范 PSR-4—自动加载规范 PSR-7—HTTP 消息接口规范 25.如何获取客户端 IP 和服务端 IP 地址客户端 IP$_SERVER[‘REMOTE_ADDR’] 浏览当前页面的用户的 IP 地址 服务端 IP$_SERVER[‘SERVER_ADDR’] 浏览当前页面的用户的 IP 地址 了解代理透传 实际IP 的概念代理一般会在HTTP的Header中传输以下3个字段：123REMOTE_ADDR // 访问端（有可能是用户，有可能是代理的）IPHTTP_X_FORWARDED_FOR // 用户是在哪个IP使用的代理（有可能存在，也可以伪造）HTTP_VIA // 代理服务器IP php客户端地址REMOTE_ADDR、HTTP_CLIENT_IP、HTTP_X_FORWARDED_FOR、HTTP_VIA 的区别及实例 26.如何开启 PHP 异常提示php.ini 开启 display_errors 设置 error_reporting 等级 运行时，使用 ini_set(k, v); 动态设置 27.如何返回一个301重定向[WARNING] 一定当心设置 301 后脚本会继续执行，不要认为下面不会执行，必要时使用 die or exit方法1：12345header(&quot;HTTP/1.1 301 Moved Permanently&quot;);header(&quot;Location: /option-a&quot;);exit(); 方法2：12345http_response_code(301);header(&apos;Location: /option-a&apos;);exit; 28.如何获取扩展安装路径phpinfo(); 页面查找 extension_dir 命令行 php -i |grep extension_dir 运行时 echo ini_get(‘extension_dir’); 29.字符串、数字比较大小的原理，注意 0 开头的8进制、0x 开头16进制字符串比较大小，从左(高位)至右，逐个字符 ASCII 比较。 字符串和数字比较，会先把字符串转换成数字类型，比如12se转换成12，abx转换成0，此时就不是字符的ASCII值与数字比较。0与任何不可转换成数字的字符串比较都是true。 两个不同进制的数字比较会转成十进制比较，得出这个结论是因为我在php中直接输出其他进制数字时均显示十进制格式。 猜想当数字字符串和非十进制数字比较大小时应该也是把数字转换成十进制形式再比较大小。 30.BOM 头是什么，怎么除去BOM头是放在UTF-8编码的文件的头部的三个字符（0xEF 0xBB 0xBF，即BOM）占用三个字节，用来标识该文件属于UTF-8编码。现在已经有很多软件识别BOM头，但是还有些不能识别BOM头，比如PHP就不能识别BOM头，所以PHP编码规范PSR-4：“无BOM的UTF-8格式”。同时这也是用Windows记事本编辑UTF-8编码后执行就会出错的原因了（Windows记事本生成文件自带BOM）。检测（具体查看超链接）去除：123456function remove_utf8_bom($text)&#123; $bom = pack(&apos;H*&apos;,&apos;EFBBBF&apos;); $text = preg_replace(&quot;/^$bom/&quot;, &apos;&apos;, $text); return $text;&#125; 31.什么是 MVCMVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 MVC模式最早由Trygve Reenskaug在1978年提出，是施乐帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。 1）最上面的一层，是直接面向最终用户的”视图层”（View）。它是提供给用户的操作界面，是程序的外壳。 2）最底下的一层，是核心的”数据层”（Model），也就是程序需要操作的数据或信息。 3）中间的一层，就是”控制层”（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果。 32.依赖注入实现原理一个用构造方法实现依赖注入的简单例子（原文链接）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php//依赖注入(Dependency injection)也叫控制反转（Inversion of Control）是一种设计模式，//这种模式用来减少程序间的耦合。//假设我们有个类，需要用到数据库连接，我们可能这样写class UseDataBase &#123; protected $adapter; public function __construct() &#123; $this-&gt;adapter=new MySqlAdapter; &#125; public function getList() &#123; $this-&gt;adapter-&gt;query(&quot;sql语句&quot;);//使用MySqlAdapter类中的query方法； &#125;&#125;class MySqlAdapter&#123;&#125;;//我们可以通过依赖注入来重构上面这个例子class UseDataBase &#123; protected $adapter; public function __construct(MySqlAdapter $adapter) &#123; $this-&gt;adapter=$adapter; &#125; public function getList() &#123; $this-&gt;adapter-&gt;query(&quot;sql语句&quot;);//使用MySqlAdapter类中的query方法； &#125;&#125;class MySqlAdapter&#123;&#125;;//但是，当我们有很多种数据库时，上面的这种方式就达不到要求或者要写很多个usedatabase类,所以我们再重构上面的这个例子class UseDataBase &#123; protected $adapter; poublic function __construct(AdapterInterface $adapter) &#123; $this-&gt;adapter=$adapter; &#125; public function getList() &#123; $this-&gt;adapter-&gt;query(&quot;sql语句&quot;);//使用AdapterInterface类中的query方法； &#125;&#125;interface AdapterInterface&#123;&#125;;class MySqlAdapter implements AdapterInterface&#123;&#125;;class MSsqlAdapter implements AdapterInterface&#123;&#125;;//这样的话，当要使用不同的数据库时，我们只需要添加数据库类实现适配器接口就够了，usedatabase类则不需要动。?&gt; 因为大多数应用程序都是由两个或者更多的类通过彼此合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么将导致代码高度耦合并且难以维护和调试。 33.如何异步执行命令不明白作者提出的这个问题是想问shell异步执行还是php异步执行脚本。 Shell异步执行： bash提供了一个内置的命令来帮助管理异步执行。wait命令可以让父脚本暂停，直到指定的进程（比如子脚本）结束。 Php异步执行脚本：方法1：必须在php.ini中注释掉disable_functions，这样popen函数才能使用。该函数打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。所以可以通过调用它，但忽略它的输出。 resource popen(string $command, string $mode) $command：linux命令，$mode：模式。 返回一个和 fopen() 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 pclose() 来关闭。此指针可以用于fgets()，fgetss() 和 fwrite()。 当模式为 ‘r’，返回的文件指针等于命令的 STDOUT，当模式为 ‘w’，返回的文件指针等于命令的 STDIN。如果出错返回 FALSE。 这种方法不能通过HTTP协议请求另外的一个WebService，只能执行本地的脚本文件。并且只能单向打开，无法穿大量参数给被调用脚本。并且如果，访问量很高的时候，会产生大量的进程。如果使用到了外部资源，还要自己考虑竞争。 方法2：12345678910$ch = curl_init(); $curl_opt = array( CURLOPT_URL=&gt;&apos;hostname/syncStock.php&apos;, CURLOPT_RETURNTRANSFER=&gt;1, CURLOPT_TIMEOUT=&gt;1,); curl_setopt_array($ch, $curl_opt); $out = curl_exec($ch); curl_close($ch); 原理：通过curl去调用一个php脚本，如果响应时间超过了1秒钟，则断开该连接，程序继续往下走而syncStock.php这个脚本还在继续往下执行。 缺点：必须设置CURLOPT_TIMEOUT=&gt;1这个属性，所以导致客户端必须至少等待1秒。但是这个属性不设置又不行，不设置的话，就会一直等待响应。就没有异步的效果了。 34.模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。 模板引擎的实现方式有很多，最简单的是“置换型”模板引擎，这类模板引擎只是将指定模板内容（字符串）中的特定标记（子字符串）替换一下便生成了最终需要的业务数据（比如网页）。 置换型模板引擎实现简单，但其效率低下，无法满足高负载的应用需求（比如有海量访问的网站），因此还出现了“解释型”模板引擎和“编译型”模板引擎等。 模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这就大大提升了开发效率，良好的设计也使得代码重用变得更加容易。 我们司空见惯的模板安装卸载等概念，基本上都和模板引擎有着千丝万缕的联系。模板引擎不只是可以让你实现代码分离（业务逻辑代码和用户界面代码），也可以实现数据分离（动态数据与静态数据），还可以实现代码单元共享（代码重用），甚至是多语言、动态页面与静态页面自动均衡（SDE）等等与用户界面可能没有关系的功能。 Smarty： Smarty是一个php模板引擎。更准确的说，它分离了逻辑程序和外在的内容，提供了一种易于管理的方法。Smarty总的设计理念就是分离业务逻辑和表现逻辑，优点概括如下： 速度——相对于其他的模板引擎技术而言，采用Smarty编写的程序可以获得最大速度的提高 编译型——采用Smarty编写的程序在运行时要编译成一个非模板技术的PHP文件，这个文件采用了PHP与HTML混合的方式，在下一次访问模板时将Web请求直接转换到这个文件中，而不再进行模板重新编译(在源程序没有改动的情况下)，使用后续的调用速度更快 缓存技术——Smarty提供了一种可选择使用的缓存技术，它可以将用户最终看到的HTML文件缓存成一个静态的HTML页面。当用户开启Smarty缓存时，并在设定的时间内，将用户的Web请求直接转换到这个静态的HTML文件中来，这相当于调用一个静态的HTML文件 插件技术——Smarty模板引擎是采用PHP的面向对象技术实现，不仅可以在原代码中修改，还可以自定义一些功能插件(按规则自定义的函数) 强大的表现逻辑——在Smarty模板中能够通过条件判断以及迭代地处理数据，它实际上就是种程序设计语言，但语法简单，设计人员在不需要预备的编程知识前提下就可以很快学会 模板继承——模板的继承是Smarty3的新事物。在模板继承里，将保持模板作为独立页面而不用加载其他页面，可以操纵内容块继承它们。这使得模板更直观、更有效和易管理 Twig： Twig是一个灵活，快速，安全的PHP模板语言。它将模板编译成经过优化的原始PHP代码。Twig拥有一个Sandbox模型来检测不可信的模板代码。Twig由一个灵活的词法分析器和语法分析器组成，可以让开发人员定义自己的标签，过滤器并创建自己的DSL。 Blade： Blade 是 Laravel 提供的一个简单而又强大的模板引擎。和其他流行的 PHP 模板引擎不同，Blade 并不限制你在视图中使用原生 PHP 代码。所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade 基本上不会给你的应用增加任何负担。Blade 视图文件使用 .blade.php 作为文件扩展名，被存放在 resources/views 目录。 35.如何实现链式操作 $obj-&gt;w()-&gt;m()-&gt;d();简单实现（关键通过做完操作后return $this;）12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass Sql&#123; private $sql=array( &quot;from&quot;=&gt;&quot;&quot;, &quot;where&quot;=&gt;&quot;&quot;, &quot;order&quot;=&gt;&quot;&quot;, &quot;limit&quot;=&gt;&quot;&quot; ); public function from($tableName) &#123; $this-&gt;sql[&quot;from&quot;]=&quot;FROM &quot;.$tableName; return $this; &#125; public function where($_where=&apos;1=1&apos;) &#123; $this-&gt;sql[&quot;where&quot;]=&quot;WHERE &quot;.$_where; return $this; &#125; public function order($_order=&apos;id DESC&apos;) &#123; $this-&gt;sql[&quot;order&quot;]=&quot;ORDER BY &quot;.$_order; return $this; &#125; public function limit($_limit=&apos;30&apos;) &#123; $this-&gt;sql[&quot;limit&quot;]=&quot;LIMIT 0,&quot;.$_limit; return $this; &#125; public function select($_select=&apos;*&apos;) &#123; return &quot;SELECT &quot;.$_select.&quot; &quot;.(implode(&quot; &quot;,$this-&gt;sql)); &#125;&#125;$sql =new Sql();echo $sql-&gt;from(&quot;testTable&quot;)-&gt;where(&quot;id=1&quot;)-&gt;order(&quot;id DESC&quot;)-&gt;limit(10)-&gt;select();//输出 SELECT * FROM testTable WHERE id=1 ORDER BY id DESC LIMIT 0,10?&gt; 利用__call()方法实现123456789101112131415161718192021222324252627282930&lt;?phpclass String&#123; public $value; public function __construct($str=null) &#123; $this-&gt;value = $str; &#125; public function __call($name, $args) &#123; $this-&gt;value = call_user_func($name, $this-&gt;value, $args[0]); return $this; &#125; public function strlen() &#123; return strlen($this-&gt;value); &#125;&#125;$str = new String(&apos;01389&apos;);echo $str-&gt;trim(&apos;0&apos;)-&gt;strlen();// 输出结果为 4；trim(&apos;0&apos;)后$str为&quot;1389&quot;?&gt; 36.Xhprof 、Xdebug 性能调试工具使用XHProf： XHProf 是一个轻量级的分层性能测量分析器。 在数据收集阶段，它跟踪调用次数与测量数据，展示程序动态调用的弧线图。 它在报告、后期处理阶段计算了独占的性能度量，例如运行经过的时间、CPU 计算时间和内存开销。 函数性能报告可以由调用者和被调用者终止。 在数据搜集阶段 XHProf 通过调用图的循环来检测递归函数，通过赋予唯一的深度名称来避免递归调用的循环。 XHProf 包含了一个基于 HTML 的简单用户界面(由 PHP 写成)。 基于浏览器的用户界面使得浏览、分享性能数据结果更加简单方便。 同时也支持查看调用图。 XHProf 的报告对理解代码执行结构常常很有帮助。 比如此分层报告可用于确定在哪个调用链里调用了某个函数。 XHProf 对两次运行进行比较（又名 “diff” 报告），或者多次运行数据的合计。 对比、合并报告，很像针对单次运行的“平式视图”性能报告，就像“分层式视图”的性能报告。 Xdebug： Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪， 调试和分析PHP程序的运行状况。Xdebug的基本功能包括在错误条件下显示堆栈轨迹，最大嵌套级别和时间跟踪。 37.索引数组 [1, 2] 与关联数组 [‘k1’=&gt;1, ‘k2’=&gt;2] 有什么区别索引数组的默认key是从0开始的数字，可省略不写；而关联数组的key是字符串，必须主动指明，字符串内容可为数字也可为其他字符。 38.为什么使用缓存提升性能：使用缓存可以跳过数据库查询，分布式系统中可以跳过多次网络开销。 在读多写少的场景下，可以有效的提高性能，降低数据库等系统的压力。 缓存的适用场景1：数据不需要强一致性 2：读多写少，并且读取得数据重复性较高 缓存的正确打开方式1：Cache Aside 同时更新缓存和数据库 2：Read/Write Through 先更新缓存，缓存负责同步更新数据库 3：Write Behind Caching 先更新缓存，缓存负责异步更新数据库 下面具体分析每种模式一、Cache Aside 更新模式 这是最常用的缓存模式了，具体的流程是： 读取：应用程序先从 cache 取数据，取到后成功返回；没有得到，则从数据库中取数据，成功后，放到缓存中。 更新：先把数据存到数据库中，再清理缓存使其失效。 不过这种模式有几个变种： 第一，如果先更新数据库再更新缓存。假设两个并发更新操作，数据库先更新的反而后更新缓存，数据库后更新的反而先更新缓存。这样就会造成数据库和缓存中的数据不一致，应用程序中读取的都是脏数据。 第二，先删除缓存再更新数据库。假设一个更新操作先删除了缓存，一个读操作没有命中缓存，从数据库中取出数据并且更新回缓存，再然后更新操作完成数据库更新。这时数据库和缓存中的数据是不一致的，应用程序中读取的都是原来的数据。 第三，先更新数据库再删除缓存。假设一个读操作没有命中缓存，然后读取数据库的老数据。同时有一个并发更新操作，在读操作之后更新了数据库并清空了缓存。此时读操作将之前从数据库中读取出的老数据更新回了缓存。这时数据库和缓存中的数据也是不一致的。 但是一般情况下，缓存用于读多写少的场景，所以第三种这种情况其实是小概率会出现的。 二、Read/Write Through 更新模式 Read Through 模式就是在查询操作中更新缓存，缓存服务自己来加载。 Write Through 模式和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库（这是一个同步操作）。 三、Write Behind Caching 更新模式 Write Behind Caching 更新模式就是在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。但其带来的问题是，数据不是强一致性的，而且可能会丢失。 总结，三种缓存模式的优缺点：Cache Aside 更新模式实现起来比较简单，最常用，实时性也高，但是需要应用需要关注核实加载数据进入缓存 。 Read/Write Through 更新模式只需要维护一个缓存，对应用屏蔽掉了缓存的细节，实时性也高。但是实现起来要复杂一些。 Write Behind Caching 吞吐量很高，多次操作可以合并。但是数据可能会丢失，例如系统断电等，实现起来最复杂。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php面试录]]></title>
    <url>%2F2016%2F07%2F20%2Fphp%E9%9D%A2%E8%AF%95%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1.php中传值和传引用的区别以及使用场景？按值传递：函数范围内对值得任何改变在函数外部都会被忽略。按引用传递：函数范围内对值得任何改变再函数外部也能反映出修改。优缺点：按值传递时：php必须复制值。特别是对于大型的字符串和对象来说，性能代价大。按引用传递时：不需复制值，对于性能提高很有好处。 2.mysql数据库中的字段类型varchar和char的主要区别是什么？varchar是变长，节省存储空间，char是固定长度。查找效率char型快，因为varchar是非定长，必须先查找长度，然后进行数据的提取。 3.mysql数据库的常用存储引擎以及他们的区别？MyISAM：不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，支持全文索引。InnoDB：支持事务，行锁，有崩溃恢复能力。读写速度比MyISAM慢，5.6之后支持全文索引。存储引擎是基于表的，而不是数据库。 4.对于大流量的网站，采用什么样的方法来解决访问量问题？首先，确认服务器硬件是否足够支持当前的流量。其次，优化数据库访问。第三，禁止外部的盗链。第四，控制大文件的下载。第五，使用不同主机分流主要流量。第六，试用流量分析统计软件。第七，尽量试用静态页，缓存。 5.什么是面向对象？主要特征是什么？面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。主要特征：封装、继承、多态。 6.session与cookie的区别是什么？session存储在服务器端，cookie保存在客户端。session比较安全，cookie用某些手段可以修改，不安全。session依赖于cookie进行传递。禁用cookie后，session还可以使用，在存储session的文件中，生成sessionID，通过get传参的方式将sessionID传到要实现session共享的页面，读取sessionID，从而从session中获取数据。 7.对缓存技术的了解？缓存技术是将动态内容缓存到文件中，在一定时间内访问动态页面直接调用缓存文件，而不必重新访问数据库。试用memcache可以做缓存。 8.表单中get和post提交方式的区别get是显式的，数据从url中可以看到，传输的数据量小，安全性低。post是隐式的，传送的数据量大，安全性高。 9.优化数据库的方法选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL试用连接（join）来代替子查询试用联合（union）来代替手动创建的临时表事务处理锁定表、优化事务处理使用外键，优化锁定表试用索引优化查询语句 10.语句include和require的区别是什么？语句include和require的区别是什么？require是无条件包含，也就是如果一个流程里加入require，无论条件成立与否都会先执行require，当文件不存在或者无法打开的时候，会提示错误，并且会终止程序执行。 include有返回值，而require没有（可能因为如此require的速度比include快），如果被包含的文件不存在的化，那么会提示一个错误，但是程序会继续执行下去。 11.redies和memcache、mongoDB的区别？都是非关系型数据库，性能都非常高，但是mongoDB和memcache、redis是不同的两种类型。后两者主要用于数据的缓存，前者主要用在查询和存储大数据方面，是最接近数据库的文档型的非关系数据库。 从数据库存储位置上来分，memcache的数据存在内存中，而redis既可以存储在内存中，也可以存储在磁盘中，达到持久化存储的功能，memcache一旦断电，数据全部丢失，redis可以利用快照和AOF把数据存到磁盘中，当恢复时又从磁盘中读取到内存中，当无力内存试用完毕后，可以把数据写入到磁盘中。 从存储数据的类型上来分，memcache和redis存储的方式都是键值对，只不过redis值得类型比较丰富，有string（字符串），hash（哈希），list（列表），set（集合），zset（有序集合），而memcache主要存储的是字符串。 12.PHP的基本变量类型四中标量类型：boolean（布尔型）、integet（整形）、float（浮点型，也称作double）、string（字符串）两种复合类型：array（数组）、object（对象）最后两种特殊类型：resource（资源）、null 13.静态化如何实现的？伪静态如何实现？1、静态化指的是页面静态化，也即生成实实在在的静态文件，也即不需要查询数据库就可以直接从文件中获取数据，指的是真静态。实现方式主要有两种：一种是我们在添加信息入库的时候就生成的静态文件，也称为模板替换技术。一种是用户在访问我们的页面时先判断是否有对应的缓存文件存在，如果存在就读缓存，不存在就读数据库，同时生成缓存文件。 2、伪静态不是真正意义上的静态化，之所以试用伪静态，主要是为了SEO推广，搜索引擎对动态的文件获取难度大，不利于网站的推广。其原理是基于Apache或Nginx的rewrite机制。主要有两种方式：一种是直接在配置虚拟机的位置配置伪静态，这个每次修改完成后需要重启web服务器。另一种采用分布式的，可以在网站的根目录上创建.htaccess的文件，在里面配置相应的重写规则来实现伪静态，这种每次重写时不需要重启web服务器，且结构上比较清晰。 14.mysql的读写分离？读写分离的实现原理就是在执行sql语句的时候，判断到底是读操作还是写操作，把读的操作转向到读服务器上（从服务器，一般是多台），写的操作转到写的服务器上（主服务器，一般是一台，视数据量来看）。当然为了保证多台数据库数据的一致性，需要主从复制。 15.如何处理负载，高并发？1、html静态化效率最高、消耗最小的警示纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。2、图片服务器分离把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如七牛等。3、数据库集群和库表散列及缓存数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。4、镜像：尽量减少下载，可以把不同的请求分发到多个镜像段。5、负载均衡：Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。 16.php单双引号？单引号内部的变量不会执行，双引号会执行。单引号解析速度比双引号块。单引号只能解析部分特殊字符，双引号可以 解析所有特殊字符。 17.php7的新特性？重点标量类型声明：php7中的函数的形参类型声明可以是标量了。在php5中只能是类名、接口、array或者callable（php5.4，即可以是函数，包括匿名函数），现在也可以使用string、int、float和bool了。返回值类型声明：增加了对返回类型声明的支持。类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。null合并运算符：由于日常使用中存在大量同时使用三元表达式和isset()的情况，null合并运算似的变量存在且值不为null，它就会返回自身的值，否则返回它的第二操作数。use加强： 从同一namespace导入的类、函数和常量现在可以通过单个use语句一次性导入了。匿名类：现在支持通过new class来实例化一个匿名类。 18.php数组排序sort() - 以升序对数组排序rsort() - 以降序对数组排序asort() - 根据值，以升序对关联数组进行排序ksort() - 根据键，以升序对关联数组进行排序arsort() - 根据值，以降序对关联数组进行排序 19.建立索引123456789101112131415161718192021(普通索引)-&gt;创建:CREATE INDEX &lt;索引名&gt; ON tablename (索引字段)修改:ALTER TABLE tablename ADD INDEX [索引名] (索引字段)创表指定索引:CREATE TABLE tablename([...],INDEX[索引名](索引字段))(唯一索引)-&gt;创建:CREATE UNIQUE &lt;索引名&gt; ON tablename (索引字段)修改:ALTER TABLE tablename ADD UNIQUE [索引名] (索引字段)创表指定索引:CREATE TABLE tablename([...],UNIQUE[索引名](索引字段))(主键)-&gt;它是唯一索引,一般在创建表是建立,格式为:CREATA TABLE tablename ([...],PRIMARY KEY[索引字段]) 20.php支持多继承吗？不支持。php中只允许单继承，父类可以被一个子类用关键字”extends”集成。 21.使用过memcache缓存吗？如果使用过，能够简单的描述一下它的工作原理吗？memcache是把所有的数据保存在内存当中，采用hash表的方式，每条数据有key和value组成，每个key是独一无二的，当要访问某个值的时候先按照找到值，然后返回结果。memcache采用LRU算法来逐渐把过期数据清除掉。 22.优化mysql数据库的方法。1.选择最有效率的表名顺序2.where子句中的连接顺序3.select子句中避免使用’*’4.用where子句替换having子句5.通过内部函数提高sql效率6.避免在索引列上试用计算7.提高group by语句的效率，可以通过将不需要的记录在group by之前过滤掉8.选取最适用的字段属性，应该尽量把字段设置为not null9.试用连接（join）来代替子查询（Sub-Queries）10.使用联合（union）来代替手动创建的临时表11.尽量少试用like关键字和通配符12.试用事务和外键 23.mysql主从备份的原理？mysql支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其他服务器充当从服务器。 24.error_reporting()的作用？设置php的报错级别并返回当前级别。 25.如何修改session的生存时间？在php.ini中设置session.gc_maxlifetime = 1440 // 默认时间代码实现：123$lifeTime = 24 * 3600; // 保存一天session_set_cookie_params($lifeTime);session_start(); 26.常见的php安全性攻击sql注入sql注入：用户利用在表单字段输入sql语句的方式来影响正常的sql执行。防止：1.使用mysql_real_escape_string()过滤数据。2.手动检查每一数组是否为正确的数据类型。3.试用预处理语句并绑定变量。4.参数化sql：是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，试用参数（Parameter）来给值，用@或?来表示参数。 XSS攻击XSS攻击：跨站点脚本攻击，由用户输入一些数据到你的网站，其中包括客户端脚本(通常JavaScript)。如果你没有过滤就输出数据到另一个web页面，这个脚本将被执行。防止：为了防止XSS攻击，使用php的htmlentities()函数过虑再输出到浏览器。 CSRFCSRF：跨站点请求伪造，是指一个页面发出的请求，看起来就像是网站的信任用户，但是是伪造的。防止：一般来说，确保用户来自你的表单，并且匹配每一个你发送出去的表单。有两点一定要记住：对用户会话采用适当的安全措施。如：给每一个会话更新id和用户使用SSL。生成另一个一次性的令牌并将其嵌入表单，保存在会话中(一个会话变量)，在提交时检查它。如：laravel中的 _token。 代码注入代码注入：代码注入是利用计算机漏洞通过处理无效数据造成的。问题出在，当你不小心执行任意代码，通常通过文件包含。写得很糟糕的代码可以允许一个远程文件包含并执行。如许多PHP函数，如require可以包含URL或文件名。防止：过滤用户输入，在php.ini中设置禁用allow_url_fopen和allow_url_include。这将禁用require/include/fopen的远程文件。 laravel是个怎样的框架？laravel框架的设计思想比较先进，非常适用应用个种开发模式，作为一个框架，它为你准备好了一切，composer是php的未来，没有composer，php肯定要走向没落。 laravel框架最大的特点和优秀之处就是集合了php比较新的特点，以及各种各样的设计模式，loc模式，依赖注入等。 laravel有哪些特点？1.强大的rest router：用简单的回调函数就可以调用，快速绑定controller和router。2.artisan：命令行工具，很多手动的工作都自动化。3.可继承的模板，简化view的开发和管理。4.blade模板：渲染速度更快。5.ORM操作数据库。6.migration：管理数据库和版本控制。7.测试功能也很强大。8.composer也是亮点。9.引入了门面，依赖注入，Ioc模式，以及各种各样的设计模式。 如何解决异常处理？抛出异常：使用try…catch，异常的代码放在try代码块内，如果没有触发异常，则代码继续执行，如果异常被触发，就会抛出一个异常。catch代码块捕获异常，并创建一个包含异常信息的对象。$e-&gt;getMessage()，输出异常的错误信息。 解决异常：试用set_error_handler函数获取异常(也可以使用try()和catch()函数)，然后使用set_exception_handler()函数设置默认的异常处理程序，register_shutdown_function()函数来执行，执行机制是，php要把调入的函数调入到内存，当页面所有的php语句都执行完成时，再调用此函数。 权限管理（RBAC）的实现？略 怎么保证促销商品不会超卖？使用redis的队列来实现。将要促销的商品数量以队列的方式存入redis中，每当用户抢到一件促销商品则从队列中删除一个数据，确保商品不会超卖。 商城秒杀的实现？抢购、秒杀这类应用场景，主要解决问题有两个：1.高并发对数据库产生的压力。2.竞争状态下如何解决库存的正确减少（超卖）问题。 对于第一个问题，使用redis缓存来处理抢购，避免直接操作数据库。第二个问题，试用redis队列来完成，把秒杀的商品放入队列中，因为pop操作是原子的，即使有很多用户同时到达，也是依次执行。其中也可能出现一个用户抢多次的情况，这时候需要再加上 一个”排队队列”和”抢购结果队列”以及”库存队列”。高并发情况下，将用户进入排队队列，用一个线程循环处理从排队队列取出一个用户，判断用户是否已在抢购结果队列，如果在，则已抢购，否则未抢购，库存减1，写数据库，将用户入结果队列。 购物车的原理？购物车相当于现实中超市的购物车，而前者一个为虚拟车，后者为实体车。用户可以在购物网站的不同页面之间跳转，以选购自己喜爱的商品，点击购买时，该商品就自动保存到你的购物车中，重复选购后，最后将选中的所有商品放在购物车中统一到付款台结账，这也是尽量让客户体验到现实生活中购物的感觉。服务器通过追踪每个用户的行动，以保证在结账时每件商品都物有其主。主要涉及以下几点：1、把商品添加到购物车，即订购。2、删除购物车中已定购的商品。3、修改购物车中某一本图书的定购数量。4、清空购物车。5、显示购物车中商品清单及数量、价格。 实现购物车的关键在于服务器识别每一个用户并维持与他们的联系。但是HTTP协议是一种“无状态(Stateless)”的协议，因而服务器不能记住是谁在购买商品，当把商品加入购物车时，服务器也不知道购物车里原先有些什么，使得用户在不同页面间跳转时购物车无法“随身携带”，这都给购物车的实现造成了一定的困难。 目前购物车的实现主要是通过cookie、session或结合数据库的方式。下面分析一下它们的机制及作用。 各种方式的选择：虽然cookie可用来实现购物车，但必须获得浏览器的支持，再加上它是存储在客户端的信息，极易被获取，所以这也限制了它存储更多，更重要的信息。所以一般cookie只用来维持与服务器的会话，例如国内最大的当当网络书店就是用cookie保持与客户的联系，但是这种方式最大的缺点是如果客户端不支持cookie就会使购物车失效。 Session能很好地与交易双方保持会话，可以忽视客户端的设置。在购物车技术中得到了广泛的应用。但session的文件属性使其仍然留有安全隐患。 (LZ选择它)结合数据库的方式虽然在一定程度上解决了上述的问题，但从上面的例子可以看出：在这种购物流程中涉及到对数据库表的频繁操作，尤其是用户每选购一次商品，都要与数据库进行连接，当用户很多的时候就加大了服务器与数据库的负荷。 redis消息队列先进先出需要注意什么?通常使用一个list来实现队列操作，这样有一个小限制，就是任务统一都是先进先出，如果想优先处理某个任务就不太好处理，这就需要让队列有优先级的概念，就可以优先处理高级别的任务。实现方式有以下几种：1、单一列表实现：队列正常的操作是 左进右出（lpush,rpop）为了先处理高优先级任务，在遇到高级别任务时，可以直接插队，直接放入队列头部（rpush），这样，从队列头部（右侧）获取任务时，取到的就是高优先级的任务（rpop） 2、使用两个队列，一个普通队列，一个高级队列，针对任务的级别放入不同的队列，获取任务时也很简单，redis的BRPOP命令可以按顺序从多个队列中取值，BRPOP会按照给出的 key 顺序查看，并在找到的第一个非空 list 的尾部弹出一个元素，redis&gt; BRPOP list1 list2 0 list1 做为高优先级任务队列list2 做为普通任务队列这样就实现了先处理高优先级任务，当没有高优先级任务时，就去获取普通任务。方式1最简单，但实际应用比较局限，方式3可以实现复杂优先级，但实现比较复杂，不利于维护。方式2是推荐用法，实际应用最为合适。 订单拆分？也就是说用户点击支付后，如果有多件商品，并且不是同一家店铺那么，就要用到订单的拆分。比如如果有两件商品，并且不是同一店铺。就在原来的订单号下，在生成两个子订单号，并修改订单表中两件商品的订单号。 用户下单是怎么处理的？判断用户有没有登陆，在没有登陆的情况下，不允许下单。登陆后，可进行下单，并生成唯一的订单号，此时订单的状态为未支付。 电商的登录是怎么实现的？分为普通登陆和第三方登陆，这边主要说一下第三方登录，第三方登陆主要使用的是author协议。以QQ的第三方登陆为例来进行说明：当用户在我们的站点请求QQ的第三方登陆时，我们站点会引导用户跳转到QQ的登陆授权界面，当用户输入QQ和密码成功登录以后会自动跳回到我们站点设置好的回调页面，并附带一个code参数，接着你使用code再次去请求QQ的授权页面，就可以从中获取到一个access_token（访问令牌）。通过这个access_token，我们可以调用QQ提供给我们的接口，比如获取open_id，可以获取用户的基本信息。获取到之后，我们需要拿用户的授权信息和open_id和我们平台的普通用户进行绑定。这样不管是普通用户登陆还是第三方登陆用户，都可以实现登陆。 接口安全方面是怎么处理的？使用HTTP的POST方式，对固定参数+附加参数进行数字签名，使用的是md5加密。比如：我想通过标题获取一个信息，在客户端使用”信息标题+日期+双方约定好的一个key”，通过md5加密生成一个签名(sign)，然后作为参数传递到服务器端，服务器端使用同样的方法进行校验，如何接受过来的sign和我们通过算法算的值相同，证明是一个正常的接口请求，我们才会返回相应的接口数据。 用什么技术实现短信发送，在哪调用？主要用第三方短信接口，在申请接口时进行相应信息的配置，然后在我们站点需要用到短信验证的地方进行调用，通常在用户注册时使用到。 用户不登录，怎么直接加入购物车？用户在不登录的情况下，可以把要购买商品的信息（如商品的ID，商品的价格、商品的sku_id,购买数量等关键数据）存到COOKIE里面，当登陆的情况下。把COOKIE里面的内容存到数据库，并清除cookie中的数据。 sku减库存？SKU = Stock Keeping Unit (库存量单位)在服装、鞋类商品中使用最多最普遍。例如纺织品中一个SKU通常表示：规格、颜色、款式。 在设计表时，不仅仅只有商品表，商品表中有个总库存，我们还需要涉及一张SKU表，里面有SKU库存和单价字段，用户每购买一件商品，实际上购买的都是SKU商品，这样在下订单成功后，应该根据所购买的商品的唯一的SKU号来进行相应的SKU库存的减少，当然商品的总库存保存在商品主表中，也需要减少总库存中的库存量。 库存设置？库存分为商品总库存和SKU库存，往往商品总库存的为SKU库存的总和。一般在商城的后台对货品设置最高库存及最低库存后，当前库存数量与最高、最低两者比较，超出库存或者低于库存的，则被统计成报表形式反映，便于用户掌握货品库存超、短缺状态及数量。 Redis如何防止高并发？其实redis是不会存在并发问题，因为他是单进程的，再多的命令都是一个接一个地执行的。但使用的时候，可能会出现并发问题。redis是一种单线进程机制的nosql数据库，基于key-value，数据可持久化落盘。由于单线程所以redis本身并没有锁的概念，多个客户端连接并不存在竞争关系，但是利用jedis等客户端对redis进行并发访问时会出现问题。发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成的。同时，单线程的天性决定，高并发对同一个键的操作会排队处理，如果并发量大，可能造成后来的请求超时。在远程访问redis的时候，因为网络等原因造成高并发访问延迟返回的问题。解决办法：在客户端将连接进行池化，同时对客户端读写redis操作采用内部所synchronized。服务器角度，利用setnx变向实现锁机制。 支付宝流程怎么实现的？ 什么是单点登录？单点登录SSO（Single Sign On）是在一个多系统共存的环境下，用户在一处登录后，就不用再其他系统中登录，也就是用户一次登录就能得到其他所有系统的信任。 合并两个数组有几种方式，试比较它们的异同array_merge 和 ‘+’ ：合并数组array_merge_recursive 合并两个数组，如果数组中有完成一样的数据，将它们递归合并 用php函数来检查用户提交的数据是否为正数12345if (!is_numeric($jp_total) || strpos($jp_total, &quot;.&quot;) !== false) &#123; echo &quot;不是正数&quot;;&#125; else &#123; echo &quot;是正数&quot;;&#125; php的strtolower()和strtoupper()函数在安装非中文系统的服务器下可能会导致将汉字转换为乱码，请写两个替代的函数实现兼容Unicode文字的字符串大小写转换。原因是中文是由多个字节组成的，而只有英文系统的单个英文字符只有一个字节，所以该系统把中文的每一个字节都做了strtolower()处理，改变后的中文字节拼接在一起就成了乱码（新生成的编码映射对应的字符可能就不是中文了）。 手动解决：用str_split(string string,intstring,intsplit_length = 1)按每个字节切割，像中文能切割成三个字节。对识别到的字节若是英文字母则进行转换。 12345678910111213141516171819&lt;?phpfunction mystrtoupper($a) &#123; $b = str_split($a, 1); $r = &apos;&apos;; foreach($b as $v)&#123; $v = ord($v); if($v &gt;= 97 &amp;&amp; $v&lt;= 122)&#123; $v -= 32; &#125; $r .= chr($v); &#125; return $r; &#125; $a = &apos;a中你继续F@#$%^&amp;*(BMDJFDoalsdkfjasl&apos;; echo &apos;origin string:&apos;.$a.&quot;\n&quot;; echo &apos;result string:&apos;; $r = mystrtoupper($a); var_dump($r); PHP的is_writeable()函数存在Bug，无法准确判断一个目录/文件是否可写，请写一个函数来判断目录/文件是否绝对可写？bug存在两个方面：1、在windowns中，当文件只有只读属性时，is_writeable()函数才返回false，当返回true时，该文件不一定是可写的。如果是目录，在目录中新建文件并通过打开文件来判断；如果是文件，可以通过打开文件（fopen），来测试文件是否可写。 2、在Unix中，当php配置文件中开启safe_mode时(safe_mode=on)，is_writeable()同样不可用。读取配置文件是否safe_mode是否开启。1234567891011121314151617181920212223242526if (!function_exists(&apos;is_really_writable&apos;)) &#123; function is_really_writable($file) &#123; // If we&apos;re on a Unix server with safe_mode off we call is_writable if (DIRECTORY_SEPARATOR == &apos;/&apos; AND @ini_get(&quot;safe_mode&quot;) == FALSE) &#123; return is_writable($file); &#125; // For windows servers and safe_mode &quot;on&quot; installations we&apos;ll actually // write a file then read it. Bah... if (is_dir($file)) &#123; $file = rtrim($file, &apos;/&apos;) . &apos;/&apos; . md5(mt_rand(1, 100) . mt_rand(1, 100)); if (($fp = @fopen($file, FOPEN_WRITE_CREATE)) === FALSE) &#123; return FALSE; &#125; fclose($fp); @chmod($file, DIR_WRITE_MODE); @unlink($file); return TRUE; &#125; elseif (!is_file($file) OR ($fp = @fopen($file, FOPEN_WRITE_CREATE)) === FALSE) &#123; return FALSE; &#125; fclose($fp); return TRUE; &#125;&#125; PHP处理上传文件信息数组中的文件类型$_FILES[‘type’]由客户端浏览器提供，有可能是黑客伪造的信息，请写一个函数来确保用户上传的图像文件类型真实可靠用getimagesize来判断上传图片的类型比$_FILES函数的type更可靠。 123456&lt;?php $file=$_FILES[&apos;file&apos;]; if(!empty($file)) &#123; var_dump($file); var_dump(getimagesize($file[&quot;tmp_name&quot;])); &#125; PHP的垃圾收集机制是怎样的？PHP使用了引用计数(referencecounting)这种单纯的垃圾回收(garbagecollection)机制。每个对象都内含一个引用计数器，每个reference连接到对象，计数器加1。当reference离开生存空间或被设为NULL，计数器减1。当某个对象的引用计数器为零时，PHP知道你将不再需要使用这个对象，释放其所占的内存空间。 通过哪一个函数，可以把错误转换为异常处理？√A：set_error_handlerB：error_reportingC：error2exceptionD：catch set_error_handler()可指定一个回调函数，错误发生时，会自动通过指定的回调函数处理。在回调函数中抛出新的异常即可。 下列哪个shell函数的描述是正确的？A：shell函数可以先调用后定义B：shell函数需使用关键字function定义√C：shell函数内的变量可以声明为局部变量D：shell函数只能通过return返回值，1是成功，0是失败 shell函数必须先定义在调用；声明时，无需使用关键字；通过local可以定义函数内的局部变量；shell函数返回值，0是成功，非0是错误，其他选项正确 下列全文检索技术的说法，不对的是：√A: Solr是新一代的全文检索组件，它比Lucene的搜索效率高很多，还能支持HTTP的访问方式，PHP调用Solr也很方便。B: MySQL中把一个字段建立FULLTEXT索引，就可以实现全文检索，目前MyISAM和InnoDB的table都支持FULLTEXT索引。C: Sphinx是一个基于SQL的全文检索引擎，可以结合MySQL做全文搜索，它可以提供比数据库本身更专业的搜索功能。D: Lucene附带的二元分词分析器CJKAnalyzer切词速度很快，能满足一般的全文检索需要。 Solr是新一代的全文检索组件，它基于Lucene，所以说它比Lucene快就是胡扯 关于单例模式的说法，错误的是？A：单例模式的目的是确保在全局环境中，一个类只能有一个实例存在B：单利模式一般要讲构造函数设置为 private√C：只需要将构造函数设置为private 即可确保全局中只有一个实例D：连接数据库的功能通常用单例模式实现 构造函数设置为private，仅能确保无法通过 new 创建新实例，但仍可以通过 clone、反序列化等方式创建多个实例。 正则的引擎表述错误的是？A 正则引擎主要可以分为两大类：一种是DFA，一种是NFA。√B 一般而论，NFA引擎则搜索更快一些。但是DFA以表达式为主导，更容易操纵，因此一般程序员更偏爱DFA引擎！C NFA表达式主导,DFA文本主导.D 可以使用是否支持忽略优先量词和分组捕获来判断引擎类型：支持 NFA,不支持 DFA 正确的说法应该是：一般而论，DFA引擎则搜索更快一些。但是NFA以表达式为主导，更容易操纵，因此一般程序员更偏爱NFA引擎！ 方框中的正则表达式能与以下哪些选项匹配？/.\123\d/ A. 123√B. **1234C. 1234D. 123 本题的要点是理解这个正则表达式的含义——从左往右，首先是零个或多个任意字符（.），跟着是一个星号（），然后是 123，最后是一个数字。 FILE表示什么意思？文件的完整路径和文件名。如果用在包含文件中，则返回包含文件名。 写出使用header函数跳转页面的语句js脚本Header(‘location:index.php’); $str是一段html文本，使用正则表达式去除其中的所有js脚本$pattern = ‘/&lt;script.*&gt;.+&lt;\/script&gt;/‘;Preg_replace($pattern, ‘’, $str); 写出将一个数组里的空值去掉的语句$arr = [‘’, 1, 2, 3, ‘’, 19]; 第一种方法：1234print_r(array_filter($arr, &quot;del&quot;));function del($var) &#123; return (trim($var));&#125; 第二种方法：12$ptn=&quot;/\S+/i&quot;;print_r(preg_grep($ptn, $arr)); 写出获取当前时间戳的函数，及打印前一天的时间的方法（格式：年-月-日 时:分:秒）12Time();Date(&quot;Y-m-d H:i:s&quot;, Strtotime(&quot;-1 day&quot;)); 写出php进行编码转换的函数1Iconv(&apos;utf-8&apos;, &apos;gb2312&apos;, $str); $str = “1, 3, 5, 7, 9, 10, 20”,使用什么函数可以把字符串str转换为包含各个数字的数组？1$arr = explode(&quot;,&quot;, $str); serialize() / unserialize() 函数的作用serialize() - 产生一个可存储的值的表示，返回值为字符串，此字符串包含了表示value的字节流，不丢失其类型和结构， unserialize() - 从已存储的表示中创建php的值 具体用法：1234$arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]; // 数组$sarr = serialize($arr); // 产生一个可存储的值（用于存储）$unsarr = unserialize($newarr); // 从已存储的表示中创建php的值 写出一个函数，参数为年份和月份，输出结果为指定月的天数123function day_count($year, $month) &#123; echo date(&quot;t&quot;, strtotime($year. &quot;-&quot;. $month. &quot;-1&quot;));&#125; 请简单写一个类，实例化这个类，并写出调用该类的属性和方法的语句12345678910clasee myclass &#123; public $aaa; public $bbb; public funciton myfun() &#123; echo &quot;this is my function&quot;; &#125; $myclass = new myclass(); $myclass-&gt;$aaa; $myclass-&gt;myfun(); 本地mysql数据库db_test里已建有表friend，数据库的连接用户为root，密码为123，friend表字段为：id，name，age，gender，phone，email。请使用php连接mysql，选择出friend表里age &gt;20 的所有记录打印结果，并统计出查询的结果总数。123456789101112&lt;?php$conn = mysqli_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;yoko(%&apos;, &apos;laravel_shop&apos;, &apos;8889&apos;);$rs = $conn-&gt;query(&quot;select * from orders where id &lt; &apos;10&apos;&quot;);// while非严格判断的，即0，空，array(), false都认为是false，同样的1, true, &apos;a&apos;, array(&apos;a&apos;)都认为是true。while($row = mysqli_fetch_array($rs, MYSQLI_NUM)) &#123; print_r($row);&#125;// 释放结果集mysqli_free_result($rs);mysqli_close($conn); 以下有两个表user表 字段 id(int), name(varchar)score表 字段 uid(int), subject(varchar)score表的uid字段与user表的id字段关联 要求写出一下sql语句1）在user表里新插入一条记录，在score表里插入与新加入的记录关联的两条记录2）获取score表里uid为2的用户score最高的5条记录3）使用联合查询获取name为“张三”的用户的总分数4）删除name为“李四”的用户，包括分数记录5）清空score表6）删除user表1234567891011121314151）mysql_query(&quot;insert into user(name) values(&apos;test&apos;)&quot;);$id = mysql_insert_id();mysql_query(&quot;insert into score(uid, subject, score) values(&quot; . $id . &quot;, &apos;english&apos;, &apos;99&apos;)&quot;);2)$sql = select uid, subject, score form score where uid = 2 order by score desc limit 0, 5;3)select s.score from score s right join user u on u.id = s.uid where u.name = &apos;张三&apos;;4)delete from score where uid in (select id from user where name = &apos;李四&apos;);delete from user where name = &apos;李四&apos;;5)dleete from score;6)drop table user; 写出一个能创建多级目录的php函数1234567891011121314&lt;?phpfunction create_dir($path, $mode = 0777) &#123; if (is_dir($path)) &#123; // 如果目录已经存在，则不创建 echo &quot;该目录已经存在&quot;; &#125; else &#123; // 不存在，创建 if (mkdir($path, $mode, true)) &#123; echo &quot;创建目录成功&quot;; &#125; else &#123; echo &quot;创建目录失败&quot;; &#125; &#125;&#125; 写出smarty模板的特点速度快，编译型，缓存技术，插件机制，强大的表现逻辑 打开php.ini中的safe_mode，会影响那些函数？至少说出6个。safe_mode，php安全模式，它提供一个基本安全的共享环境，在一个有个用户账户存在的php开发web服务器上。当安全模式打开时，一些函数将被完全的禁止，而另一些函数的功能将会受到限制。如：chdir,move_uploaded_file,chgrp,parse_ini_file,chown,rmdir,copy,rename,fopen,require,mkdir,unlink等。注意，在php5.3以上版本，safe_mode被弃用，在php5.4以上版本，则将此特性完全去除了。 抓取原生图片到本地，你会用什么函数？file_get_contents或者curl 请写一段php代码，确保多个进程同时写入同一个文件成功核心思想：加锁123456789101112&lt;?php $fp = fopen(&quot;lock.txt&quot;, &quot;w+&quot;); if (flock($fp, LOCK_EX)) &#123; //获取写锁，写数据 fwrite($fp, &quot;write something&quot;); // 解除锁定 flock($fp, LOCK_UN); &#125; else &#123; echo &quot;file is locking...&quot;; &#125; fclose($fp); 写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名，例如:http://www.sina.com.cn/abc/de/fg.php?id=1需要取出php或.php123456789101112131415161718192021222324252627&lt;?php // 方案一 function getExt1($url) &#123; $arr = parse_url($url); // Array ( [scheme] =&gt; http [host] =&gt; www.sina.com.cn [path] =&gt; /abc/de/fg.php [query] =&gt; id=1 ) $file = basename($arr[&apos;path&apos;]); $ext = explode(&quot;.&quot;, $file); return $ext[count($ext) - 1]; &#125; // 方案二 function getExt2($rul) &#123; $url = basename($url); $pos1 = strpos($url, &quot;.&quot;); $pos2 = strpos($url, &quot;?&quot;); if (strstr($url, &quot;?&quot;)) &#123; return substr($url, $pos1 + 1, $pos2 - $pos1 - 1); &#125; else &#123; return substr($url, $pos1); &#125; &#125; $path = &quot;http://www.sina.com.cn/abc/de/fg.php?id=1&quot;; echo getExt1($path); echo &quot;&lt;br /&gt;&quot;; echo getExt2($path); 写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。123456789101112131415161718function my_scandir($dir) &#123; $files = []; if (is_dir($dir)) &#123; if ($handle = opendir($dir)) &#123; while (($file = readdir($handle)) !=== false) &#123; if ($file != &quot;.&quot; &amp;&amp; $file != &quot;..&quot;) &#123; if (is_dir($dir. &quot;/&quot; .$file)) &#123; $files[$file] = my_scandir($dir. &quot;/&quot;. $file); &#125; else &#123; $files[] = $dir. &quot;/&quot; .$file; &#125; &#125; &#125; closedir($handle); return $files; &#125; &#125;&#125; 简述论坛中无限分类的实现原理。创建类别表如下：12345create table category ( cat_id smallint unsigned not null auto_increment primary key comment &apos;类别ID&apos;, cat_name varchar(30) not null default &apos;&apos; comment &apos;类别名称&apos;, parent_id smallint unsigned not null default 0 comment &apos;类别父ID&apos;)engine=MyISAM charset=utf8; 编写一个函数，递归遍历，实现无限分类123456789101112function tree($arr, $pid = 0, $level = 0) &#123; static $list = []; foreach ($arr as $v) &#123; // 如果是顶级分类，则将其存到$list中，并以此节点为根节点，遍历其子节点 if ($v[&apos;parent_id&apos;] == $pid) &#123; $v[&apos;level&apos;] = $level; $list[] = $v; tree($arr ,$v[&apos;cat_id&apos;], $level+1); &#125; &#125; return $list;&#125; 写一个函数，算出两个文件的相对路径，如b=’/a/b/12/34/c.php’; 计算出a的相对路径应该是../../c/d1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpfunction releative_path($path1, $path2) &#123; $arr1 = explode(&quot;/&quot;, dirname($path1)); $arr2 = explode(&quot;/&quot;, dirname($path2)); for ($i = 0; $len = count($arr2); $i &lt; $len; $i ++) &#123; if ($arr1[$i] != $arr2[$i]) &#123; break; &#125; &#125; // 不再同一个目录下 if ($i == 1) &#123; $return_path = []; &#125; // 在同一个目录下 if ($i != 1 &amp;&amp; $i &lt; $len) &#123; $return path = array_fill(0, $len = $i, &quot;..&quot;); &#125; // 在同一个目录下 if ($i == $len) &#123; $return_path = [&apos;./&apos;]; &#125; $return_path = array_merge($return_path, array_slice($arr1, $i)); return implode(&apos;/&apos;, $return_path);&#125;$a = &apos;/a/b/c/d/e.php&apos;;$b = &apos;/a/b/12/34/c.php&apos;;$c = &apos;/e/b/c/d/f.php&apos;;$d = &apos;/a/b/c/d/g.php&apos;;echo releative_path($a,$b);//结果是../../c/decho &quot;&lt;br /&gt;&quot;;echo releative_path($a,$c);//结果是a/b/c/decho &quot;&lt;br /&gt;&quot;;echo releative_path($a,$d);//结果是./echo &quot;&lt;br /&gt;&quot;; mysql_fetch_row() 和 mysql_fetch_array() 有什么分别？mysql_fetch_row()把数据库的一列储存在一个以零为基数的数组中，第一栏在数组的索引0，第二栏在索引1，依此类推。mysql_fetch_assoc()把数据库的一列储存在一个关联数组中，数组的索引就是字段名称，例如我的数据库查询送回“first_name”、“last_name”、“email”三个字段，数组的索引便是“first_name”、“last_name”和“email”。mysql_fetch_array()可以同时送回mysql_fetch_row()和mysql_fetch_assoc()的值。 有一个网页地址,比如PHP开发资源网主页:http://www.phpres.com/index.html,如何得到它的内容?方法1（对于php5以及更高版本）：1234$readcontents = fopen(&quot;http://www.phpres.com/index.html&quot;, &quot;rb&quot;);$contents = stream_get_contents($readcontents);fclose($readcontents);echo $contents; 方法2：1echo file_get_contents(&quot;http://www.phpres.com/index.html&quot;); 请写一个函数验证电子邮件的格式是否正确（要求使用正则）1preg_match(&apos;/^[\w\-\.]+@[\w\-]+(\.\w+)+$/&apos;,$email); php如何判断一个字符串是否是合法的日期模式：2007-03-13 13:13:13。要求代码不超过5行。1234567891011121314function checkDateTime($data) &#123; if (date(&apos;Y-m-d H:i:s&apos;, strtotime($data)) == $data) &#123; return true; &#125; else &#123; return false; &#125;&#125;// 示例$data = &apos;2015-06-20 13:35:42&apos;;var_dump(checkDateTime($data));//bool(true)$data = &apos;2015-06-36 13:35:42&apos;;var_dump(checkDateTime($data));//bool(false) php中，如何获取一个数组的键值？使用key()可以获得数组中当前元素的键名，使用current()则可以返回当前元素的值。使用array_keys()则可以得到数组中所有的键名。使用foreach结构foreach($arr as value)可以通过value分别获取键名和值。 以下哪个错误无法被标准的错误控制器获取？A.E_WARNING√B.E_USER_ERRORC.E_PARSED.E_NOTICE 以下哪种错误类型无法被自定义的错误处理器捕捉到?A.E_WARNINGB.E_USER_ERROR√C.E_PARSED.E_NOTICE 如何把2009-9-2 10:30:25变成unix时间戳？1234567891011121314&lt;?phpdate_default_timezone_set(&quot;PRC&quot;);// 将字符串转成Unix时间戳$unix_time = strtotime(&quot;2009-9-2 10:30:45&quot;);echo $unix_time;echo &quot;&lt;br /&gt;&quot;;// 格式化Unix时间戳为正常时间格式echo date(&quot;Y-m-d H:i:s&quot;,$unix_time);?&gt; 如何把一个GB2312格式的字符串装换成UTF-8格式？1iconv(&apos;GB2312&apos;,&apos;UTF-8&apos;,&apos;悄悄是别离的笙箫&apos;); 写出五种以上你使用过的PHP的扩展的名称（提示：常用的PHP扩展）mb_sring、iconv、curl、GD、XML、socket、MySQL、PDO等 _函数能返回脚本里的任意行中调用的函数的名称。该函数同时还经常被用在调试中，用来判断错误是如何发生的。1debug_print_backtrace() 数组[‘a’, ‘b’, ‘c’]转换成字符串’abc’12echo implode(&apos;&apos;, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);echo join([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], &apos;&apos;); 获取字符串’aAbB’中首次出现的位置12$str = &apos;aAbB&apos;;echo strpos($str, &quot;A&quot;); 编写一段用最小代价实现将字符串完全反序, e.g. 将 “1234567890” 转换成 “0987654321”. (用php语言编写并标注简单注释, 不要使用函数)1234567$s = &apos;1234567890&apos;;$o = &apos;&apos;;$i = 0;while(isset($s[$i]) &amp;&amp; $s[$i] != null) &#123; $o = $s[$i++].$o;&#125;echo $o; 请用递归实现一个阶乘求值算法 F(n): n=5;F(n)=5!=54321=120123456789function F($n) &#123; if($n == 0) &#123; return 1; &#125; else &#123; return $n * F($n-1); &#125;&#125;var_dump(F(5)); 将字符串长fang-zhi-gang 转化为驼峰法的形式：FangZhiGang12345678910111213function Fun($str) &#123; if(isset($str) &amp;&amp; !empty($str)) &#123; $newStr = &apos;&apos;; if(strpos($str, &apos;-&apos;) &gt; 0) &#123; $strArray = explode(&apos;-&apos;, $str); $len = count($strArray); for ($i = 0; $i &lt; $len; $i ++); &#123; $newStr .= ucfirst($strArray[$i]); &#125; &#125; return $newStr; &#125;&#125; php不使用第三个变量实现交换两个变量的值12345678// 方法一$a .= $b;$b = str_replace($b, &quot;&quot;, $a);$a = str_replace($b, &quot;&quot;, $a);// 方法二list($b, $a) = [$a, $b];var_dump($a, $b); mysql的几个概念：主键，外键，索引，唯一索引主键(primary key) 能够唯一标识表中某一行的属性或属性组。一个表只能有一个主键，但可以有多个候选索引。主键常常与外键构成参照完整性约束，防止出现数据不一致。主键可以保证记录的唯一和主键域非空,数据库管理系统对于主键自动生成唯一索引，所以主键也是一个特殊的索引。 外键（foreign key） 是用于建立和加强两个表数据之间的链接的一列或多列。外键约束主要用来维护两个表之间数据的一致性。简言之，表的外键就是另一表的主键，外键将两表联系起来。一般情况下，要删除一张表中的主键必须首先要确保其它表中的没有相同外键（即该表中的主键没有一个外键和它相关联）。 索引(index) 是用来快速地寻找那些具有特定值的记录。主要是为了检索的方便，是为了加快访问速度， 按一定的规则创建的，一般起到排序作用。所谓唯一性索引，这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一。 总结：主键一定是唯一性索引，唯一性索引并不一定就是主键。一个表中可以有多个唯一性索引，但只能有一个主键。主键列不允许空值，而唯一性索引允许空值。主键可以被其他字段作外键引用，而索引不能作为外键引用。 php序列化和反序列化 函数12serialize() 序列化unserialize() 反序列化 求两个日期的差数，例如2007-2-5 ~ 2007-3-6的日期差数123456789// 方法一:用DateTime类$day1 = &apos;2003-09-16&apos;;$day2 = &apos;2011-11-23&apos;;$d1 = new dateTime($day1);$d2 = new dateTime($day2);echo $d1-&gt;diff($d2)-&gt;days;// 方法二,用时间戳计算echo (strtotime($day2) - strtotime($day1)) / (24*3600); 下列代码的输出是()1234&lt;?phpdefine(&quot;x&quot;, &quot;5&quot;);$x = x + 10;echo x; A．Error √B．5 C．10 D．15分析：常量不变 如何对变量进行引用？可以在变量的前面加&amp;符号对变量进行引用，变量的引用相当于给变量起了个别名，通过不同的名字访问同一个变量内容，所以改变其中一个变量的值，另一个变量也会跟着改变。例（真题）：123456&lt;?php $a=&quot;hello&quot;; $b= &amp;$a; unset($b); $b=&quot;world&quot;; echo $a; 程序的运行结果为（ ）√A．hello B．world C．NULL D．unset分析：1）首先执行$b= &amp;$a后，a和b引用同一个字符串变量“hello”。2）接着执行unset($b)，这个函数可以断开这个引用关系。此时由于a仍然指向字符串“hello”，也就是说，这个字符串仍然被a使用，因此这个字符串不会被回收。3）接着执行$b=”world”，此时，b指向一个新的字符串“world”，这并不会影响a的值。因此输出结果为hello。 mysql主从同步的原理从两种说法去理解主从同步原理。第一种说法：123456789101112主库有一个IO线程，从库上又一个IO线程和一个SQL线程。从库中的IO线程负责从主库读取binlog，并写入从库的中续日志。SQL线程负责读取并执行中继日志中的binlog，转换sql语句后应用数据库汇总。 通信是： 从库的IO线程给主库发送同步请求，请求中包含用户名密码和binlog的文件名，pos点 主库验证成功后，发送从库需要的binlog日志文件，和binlog文件中pos点 从库的IO线程接收后，把binlog文件转存到中继日志的relay-log文件，并把binlog文件名和pos点记录到master.info文件中，方便下次通信使用 从库的SQl线程监测出relay-log文件后，把relay-log文件转换为binlog文件在本地执行，并把relay-log文件名和pos点记录到relay-log.info文件中 从库再次发送下一轮的请求 如果slave后面还挂有从库则也要开启binlog，并添加一个参数log-slave-updates 第二种说法：123456789101112mysql主从同步：当master(主)库的数据发生变化的时候，变化会实时的同步到slave(从)库。好处：水平扩展数据库的负载能力。容错，高可用。Failover(失败切换)/High Availability数据备份。原理：首先我们来了解master-slave的体系结构。不管是delete、update、insert，还是创建函数、存储过程，所有的操作都在master上。当master有操作的时候,slave会快速的接收到这些操作，从而做同步。实现：在master机器上，主从同步事件会被写到特殊的log文件中(binary-log);在slave机器上，slave读取主从同步事件，并根据读取的事件变化，在slave库上做相应的更改。 PHP抽象类PHP中抽象类使用abstract关键字定义。没有方法体的方法叫抽象方法，包含抽象方法的类必须是抽象类。抽象类可以是个空类，也就是不一定需要有抽象方法。但抽象方法只能存在抽象类中。抽象类不能实例化，也就是不可以new成对象。 什么是多态？多态是面向对象程序设计中代码重用的一个重要机制，它表示当同一个操作作用在不同对象的时候，会有不同的语义，从而会产生不用的结果。例如，同样是”+”操作，3+4用来实现整数相加，而”3”+”4”却实现了字符串的连接。一般而言，多态有两种实现方式：覆盖和重载。 设教务管理系统中有三个基本表：学生信息表s(sno, sname, age, sex)，其属性分别表示学号、学生姓名、年龄和性别。选课信息表sc(sno, cno, scgrade)，其属性分别表示学号、课程号和成绩。课程信息表c(cno, cname, cteacher)，其属下分别表示课程号、课程名称和任课老师姓名。 1）把sc表中每门课程的平均成绩插入另外一个已经存在的表sc_c(cno, cname, avg_grade)中，其中avg_grade表示的是每门课程的平均成绩。12insert into sc_c(cno, cname, avg_grade)select sc.cno, c.cname, avg(scgrade) from sc, c where sc.cno = c.cno group by sc.cno 2）规定女同学选修何昊老师的课程成绩都应该在80分以上（包含80分）。123alert table sc, s, cadd constraint grade check(scgrade &gt;= 80)where sc.cno = c.cno and sc.sno = s.sno and c.cteacher = &apos;何昊&apos; and s.sex = &apos;女&apos; 3）从SC表中把何昊老师的女学生选课记录删除。1delete from sc where cno = (select cno from c where c.cteacher = &apos;何昊&apos;) and sno in (select sno from s where sex = &apos;女&apos;) 4）找出没有选修过“何昊”老师讲授课程的所有学生姓名。12select sname from swhere not exists(select * from sc,c where sc.cno = c.cno and cname = &apos;何昊&apos; and sc.sno = s.sno) 5）列出有两门以上（含两门）不及格课程（成绩小于60）的学生姓名及其平均成绩。1234select s.sno, s.sname, avg_scgrade = avg(sc.scgrade)from s, sc, (select sno from sc where scgrade &lt; 60 group by sno having count(distinct cno) &gt;= 2) a where s.sno = a.sno and sc.sno = a.sno group by s.sno, s.sname 6）列出既学过”1”号课程，又学过”2”号课程的所有学生姓名12select s.sno, s.snamefrom s, (select sc.sno and c.cname in(&apos;1&apos;, &apos;2&apos;) 7）列出“1”号课成绩比“2”号同学该门课成绩高的所有学生的学号。12345select s.sno, s.snamefrom s, (select sc1.sno from sc sc1, c c1, sc sc2, c c2 where sc1.cno = c1.cno and c1.name = &apos;1&apos; and sc2.cno = c2.cno and c2.name = &apos;2&apos; and sc1.scgrade &gt; sc2.scgrade) sc where s.sno = sc.sno 8）列出“1”号课成绩比“2”号课成绩高的所有学生的学号及其“1”号课和“2”号课的成绩。 select s.sno, s.sname, sc.[1号课成绩], sc.[2号课成绩] from s, (select sc1.sno, [1号课成绩] = sc1.scgrade, [2号课成绩] = sc2.scgrade from sc sc1, c c1, sc sc2, c c2 where sc1.cno = c1.cno and c1.name = &apos;1&apos; and sc2.cno = c2.cno and c2.name = &apos;2&apos; and sc1.scgrade &gt; sc2.scgrade) sc where s.sno = sc.sno 更改表字段名的标准语法为（ ）A．alter table 表名 add 字段字类型[first|after]B．alter table 表名 drop 字段[first|after]√C．alter table 表名 change 原名新名新类型[first|after]D．alter table 表名 modify 原名字段类型[first|after] 分析：修改表字段名的语法：alter table 表名change 原字段名新字段名类型。修改字段类型的语法：alter table 表名modify 字段名类型。增加一个字段：alter table 表名add column 字段名类型 not null（或default null）；新增一个字段默认不为空（默认为空）。删除一个字段：alter table 表名drop column 新字段名。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常用函数]]></title>
    <url>%2F2016%2F07%2F06%2Fphp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.数组函数 array_chunk // 将一个数组分割成多个 array_column // 返回数组中指定的一列 array_combine // 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值（另一种意义的合并数组） array_flip // 交换数组中的键和值 array_key_exists // 检查数组里是否有指定的键名或索引 array_key_first // 返回数组第一个键的键名 array_key_last // 返回数组最后一个键的键名 array_keys // 返回数组键名 array_merge // 合并一个或多个数组 array_pop // 弹出数组最后一个单元；出栈；删除数组最后一个单元 array_push // 将一个或多个单元压入数组的末尾；入栈；合并数组 array_rand // 从数组中随机取出一个或多个单元 array_reverse // 返回单元顺序相反的数组 array_search // 在数组中搜索给定的值，如果成功则返回首个相应的键名 array_shift // 将数组开头的单元移出数组 array_slice // 从数组中取出一段 array_sum // 对数组中所有值求和 array_unique // 移除数组中重复的值 array_unshift // 在数组开头插入一个或多个单元 array_values // 返回数组中所有的值 arsort // 对数组进行逆向排序并保持索引关系 asort // 对数组进行排序并保持索引关系 count // 计算数组中的单元数目，或对象中的属性个数 current // 返回数组中的当前单元 in_array // 检查数组中是否存在某个值 krsort // 对数组按照键名逆向排序 ksort // 对数组按照键名排序 list // 把数组中的值赋给一组变量 shuffle // 打乱数组 sort // 对数组排序 uasort // 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 uksort // 使用用户自定义的比较函数对数组中的键名进行排序 usort // 使用用户自定义的比较函数对数组中的值进行排序 2.string(字符串)函数 chunk_split // 将字符串分割成小块 explode // 使用一个字符串分割另一个字符串 implode // 将一个一维数组的值转化为字符串 lcfirst // 使一个字符串的第一个字符小写 ltrim // 删除字符串开头的空白字符（或其他字符） md5 // 计算字符串的 MD5 散列值 money_format // 将数字格式化成货币字符串 nl2br // 在字符串所有新行之前插入 HTML 换行标记 number_format // 以千位分隔符方式格式化一个数字 ord // 返回字符的 ASCII 码值 rtrim // 删除字符串末端的空白字符（或者其他字符） str_replace // 子字符串替换 str_ireplace // str_replace 的忽略大小写版本 str_repeat // 重复一个字符串 str_shuffle // 随机打乱一个字符串 str_split // 将字符串转换为数组 stripos // 查找字符串首次出现的位置（不区分大小写） strpos // 查找字符串首次出现的位置 strstr // 查找字符串的首次出现 stristr // strstr 函数的忽略大小写版本 strlen // 获取字符串长度 strrchr // 查找指定字符在字符串中的最后一次出现 strrev // 反转字符串 strripos // 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写） strrpos // 计算指定字符串在目标字符串中最后一次出现的位置 strtok // 标记分割字符串 strtolower // 将字符串转化为小写 strtoupper // 将字符串转化为大写 substr_count // 计算字串出现的次数 substr_replace // 替换字符串的子串 substr // 返回字符串的子串 trim // 去除字符串首尾处的空白字符（或者其他字符） ucfirst // 将字符串的首字母转换为大写 ucwords // 将字符串中每个单词的首字母转换为大写 wordwrap // 打断字符串为指定数量的字串]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[名词备忘]]></title>
    <url>%2F2016%2F07%2F05%2F%E5%90%8D%E8%AF%8D%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[12345678910111213数组 = 数组 = 集合数列 = 规则数组函数F(x)的F只是名字值域 = 函数值范围定义域 = x取值范围键名 key值 value索引数组中的单元数目出栈入栈对象中的属性个数迭代 = 循环]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用步骤]]></title>
    <url>%2F2016%2F07%2F04%2Fhexo%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
