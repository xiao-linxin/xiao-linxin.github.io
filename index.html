<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>xiao-linxin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="xiao-linxin">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="xiao-linxin">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xiao-linxin">
  
    <link rel="alternate" href="/atom.xml" title="xiao-linxin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://img.xingyiss.com/IMG_4296.JPG">
    <h2 class="author">xiao-linxin</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>7</strong><br>文章</div></a>
      <a href="/categories"><div><strong>3</strong><br>分类</div></a>
      <a href="/tags"><div><strong>3</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/search" title="search">
            <li>搜索</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-php实践" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/01/php实践/" class="article-date">
  <time class="post-time" datetime="2016-08-31T16:00:00.000Z" itemprop="datePublished">
    <span class="post-month">9月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
  </div>

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/01/php实践/">php实践</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2016/09/01/php实践/" class="leancloud_visitors" data-flag-title="php实践">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="php实践（一）"><a href="#php实践（一）" class="headerlink" title="php实践（一）"></a>php实践（一）</h1><hr>
<h2 id="1-给定二维数组，根据某个字段排序"><a href="#1-给定二维数组，根据某个字段排序" class="headerlink" title="1.给定二维数组，根据某个字段排序"></a>1.给定二维数组，根据某个字段排序</h2><p>一组学生信息，要按年龄大小升序或降序排序（类似与sql语句的order by功能）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$arr = [</span><br><span class="line">    [&apos;id&apos; =&gt; 6, &apos;name&apos; =&gt; &apos;小明&apos;],</span><br><span class="line">    [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;小亮&apos;],</span><br><span class="line">    [&apos;id&apos; =&gt; 13, &apos;name&apos; =&gt; &apos;小红&apos;],</span><br><span class="line">    [&apos;id&apos; =&gt; 2, &apos;name&apos; =&gt; &apos;小强&apos;],</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 方法1：手动写排序方法：</span><br><span class="line"></span><br><span class="line">/** 对给定二维数组按照某个字段升序或降序排序</span><br><span class="line"> * @param $arr 给定一个二维数组，这里的$arr</span><br><span class="line"> * @param $sortField 根据哪个字段排序，这里的id</span><br><span class="line"> * @param string $sort 升序还是降序,默认升序</span><br><span class="line"> * 思路：取出所有要排序的字段的值组成一个新数组，根据升序降序保留键值排序，此时新数组的键值顺序就是要得到的排序后的二维数组的键值顺序，然后将原二维数组按照此键值顺序排列即可。</span><br><span class="line"> * 注意：这里没有重置排序后的二维数组的索引，如需重置可自行扩展</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">private function arraySort($arr, $sortField, $sort = &apos;asc&apos;) &#123;</span><br><span class="line">    $newArr = array();</span><br><span class="line">    foreach ($arr as $key =&gt; $value) &#123;</span><br><span class="line">        $newArr[$key] = $value[$sortField];</span><br><span class="line">    &#125;</span><br><span class="line">    ($sort == &apos;asc&apos;) ? asort($newArr) : arsort($newArr);</span><br><span class="line">    foreach ($newArr as $k =&gt; $v) &#123;</span><br><span class="line">        $newArr[$k] = $arr[$k];</span><br><span class="line">    &#125;</span><br><span class="line">    return $newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法2：使用php提供的排序函数array_multisort（），默认会重置排序后的索引，即从0开始顺序往下排</span><br><span class="line"></span><br><span class="line">foreach ($arr as $key =&gt; $value) &#123;</span><br><span class="line">    $id[$key] = $value[&apos;id&apos;];</span><br><span class="line">&#125;</span><br><span class="line">array_multisort($id, SORT_ASC, $arr); // 返回True or False</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="2-如何判断上传文件类型，如：仅允许-jpg-上传"><a href="#2-如何判断上传文件类型，如：仅允许-jpg-上传" class="headerlink" title="2.如何判断上传文件类型，如：仅允许 jpg 上传"></a>2.如何判断上传文件类型，如：仅允许 jpg 上传</h2><p>网上出现频率较高的一段代码：lz认为此段代码对上传文件的类型限制还是比较好的，<br>因为之前看资料说仅通过mime类型判断有时候不太靠谱，<br>而仅通过文件后缀名判断好像也不是很靠谱，<br>所以这里采用双重判断，以下代码稍微加了点注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$allowedExts = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;);  // 限定可上传的文件后缀名</span><br><span class="line"></span><br><span class="line">$extension = end(explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;])); // 从文件名中获取文件后缀名</span><br><span class="line"></span><br><span class="line">// 判断上传文件mime类型是下列之一且大小小于20000B且文件后缀名也符合要求</span><br><span class="line"></span><br><span class="line">if (( ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/x-png&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/png&quot;)) &amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 20000) &amp;&amp; in_array($extension, $allowedExts)) &#123;</span><br><span class="line">    if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) &#123;</span><br><span class="line">        echo &quot;Return Code: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;;</span><br><span class="line">        echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;;</span><br><span class="line">        echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; kB&lt;br&gt;&quot;;</span><br><span class="line">        echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] . &quot;&lt;br&gt;&quot;; //临时文件名</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])) &#123; </span><br><span class="line">        // 同名文件已存在时提示文件已存在</span><br><span class="line">        echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]);</span><br><span class="line">        echo &quot;Stored in: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-不使用临时变量交换两个变量的值-a-1-b-2-gt-a-2-b-1"><a href="#3-不使用临时变量交换两个变量的值-a-1-b-2-gt-a-2-b-1" class="headerlink" title="3.不使用临时变量交换两个变量的值 $a=1; $b=2; =&gt; $a=2; $b=1;"></a>3.不使用临时变量交换两个变量的值 $a=1; $b=2; =&gt; $a=2; $b=1;</h2><p>最先想到的利用加减运算这里就不说了，因为那只适用于数字类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.字符串截取法：</span><br><span class="line">function myExchange(&amp;$a = &apos;&apos;, &amp;$b = &apos;&apos;) &#123;</span><br><span class="line">    $a = $a . $b;</span><br><span class="line">    $b = substr($a,0,-strlen($b));</span><br><span class="line">    $a = substr($a,strlen($a)-strlen($b),strlen($b));</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.数组法：    </span><br><span class="line">private function myExchange(&amp;$a = &apos;&apos;, &amp;$b = &apos;&apos;) &#123;</span><br><span class="line">    $a = array($a, $b);</span><br><span class="line">    $b = $a[0];</span><br><span class="line">    $a = $a[1];</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-strtoupper-在转换中文时存在乱码，你如何解决？php-echo-strtoupper-‘ab你好c’"><a href="#4-strtoupper-在转换中文时存在乱码，你如何解决？php-echo-strtoupper-‘ab你好c’" class="headerlink" title="4.strtoupper 在转换中文时存在乱码，你如何解决？php echo strtoupper(‘ab你好c’);"></a>4.strtoupper 在转换中文时存在乱码，你如何解决？php echo strtoupper(‘ab你好c’);</h2><p>php echo strtoupper(‘ab你好c’);（经测试中文系统下不会出现乱码，网上资料说是英文系统或部分盗版系统或因编码格式问题可能出现题述情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 1.mb系列函数解决（mb系列函数可以显式指明编码）</span><br><span class="line">string mb_convert_case (string $str ,int $mode [,string $encoding = mb_internal_encoding()])</span><br><span class="line"></span><br><span class="line">$mode有三种模式： </span><br><span class="line">1.MB_CASE_UPPER：转成大写 </span><br><span class="line">2.MB_CASE_LOWER：转成小写 </span><br><span class="line">3.MB_CASE_TITLE ：转成首字母大写</span><br><span class="line"></span><br><span class="line">$encoding默认使用内部编码；也可以显示使用如’UTF-8’; </span><br><span class="line">可以用echo mb_internal_encoding();来查看；</span><br><span class="line">此方法不仅可以解决中文问题，对其他问题也适用。</span><br><span class="line"></span><br><span class="line">2.手动解决：用str_split(string $string, int $split_length = 1)按每个字节切割，</span><br><span class="line">像中文能切割成三个字节。对识别到的字节若是英文字母则进行转换。</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">function mystrtoupper($a)&#123;</span><br><span class="line">    $b = str_split($a, 1);</span><br><span class="line">    $r = &apos;&apos;;</span><br><span class="line">    foreach($b as $v)&#123;</span><br><span class="line">        $v = ord($v);//对该字符转成acsii码</span><br><span class="line">        if($v &gt;= 97 &amp;&amp; $v&lt;= 122)&#123;//判断是否为小写字母</span><br><span class="line">            $v -= 32;//转换成大写字母</span><br><span class="line">        &#125;</span><br><span class="line">        $r .= chr($v);//将ascii码再转为相应的字符。</span><br><span class="line">    &#125;</span><br><span class="line">    return $r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = &apos;a中你继续F@#$%^&amp;*(BMDJFDoalsdkfjasl&apos;;echo &apos;origin string:&apos;.$a.&quot;\n&quot;;echo &apos;result string:&apos;;$r = mystrtoupper($a);</span><br><span class="line">var_dump($r);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-Websocket、Long-Polling、Server-Sent-Events-SSE-区别"><a href="#5-Websocket、Long-Polling、Server-Sent-Events-SSE-区别" class="headerlink" title="5.Websocket、Long-Polling、Server-Sent Events(SSE) 区别"></a>5.Websocket、Long-Polling、Server-Sent Events(SSE) 区别</h2><p><a href="https://www.jianshu.com/p/4aa085b9984b" target="_blank" rel="noopener">Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE</a></p>
<hr>
<h2 id="6-”Headers-already-sent”-错误是什么意思，如何避免"><a href="#6-”Headers-already-sent”-错误是什么意思，如何避免" class="headerlink" title="6.”Headers already sent” 错误是什么意思，如何避免"></a>6.”Headers already sent” 错误是什么意思，如何避免</h2><p>StackOverflow原文链接</p>
<p>错误说明：“不能更改头信息-头已经发出”；意思大概是在你的代码中有修改header信息的代码段，但是在此代码段之前header已经发出，所以报错不能修改。</p>
<p>如何避免：在发送header前不能有任何输出，会发送header的部分方法：</p>
<p>header / header_remove<br>session_start / session_regenerate_id<br>setcookie / setrawcookie<br>类似于输出功能的操作（不能放在header相关处理之前）：</p>
<p>无意的：<br>&lt;?php之前或?&gt;之后的空格<br>UTF-8编码的BOM头信息<br>以前的错误消息或通知</p>
<p>故意的：</p>
<p>print，echo等产生输出的输出<br>Raw <html> sections prior &lt;?php code.（抱歉没有看懂）</html></p>
<hr>

      
    </div>

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/01/php实践/" data-id="cjxmd3ccq00036vhnp5c99amm" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>








  
    <article id="post-php算法" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/01/php算法/" class="article-date">
  <time class="post-time" datetime="2016-08-31T16:00:00.000Z" itemprop="datePublished">
    <span class="post-month">9月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
  </div>

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/01/php算法/">php算法</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2016/09/01/php算法/" class="leancloud_visitors" data-flag-title="php算法">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="php算法"><a href="#php算法" class="headerlink" title="php算法"></a>php算法</h1><hr>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function maopao($arr) &#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    $n = count($arr) - 1;</span><br><span class="line">    for ($i = 0; $i &lt; $len; $i++) &#123;</span><br><span class="line">        for ($j = 0; $j &lt; $n; $j++) &#123;</span><br><span class="line">            if ($arr[$j] &gt; $arr[$j + 1]) &#123;</span><br><span class="line">                $tmp = $arr[$j];</span><br><span class="line">                $arr[$j] = $arr[$j + 1];</span><br><span class="line">                $arr[$j + 1] = $tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function quick_sort($array) &#123;</span><br><span class="line">    if (count($array) &lt;= 1) return $array;</span><br><span class="line">    $key = $array[0];</span><br><span class="line">    $left_arr = array();</span><br><span class="line">    $right_arr = array();</span><br><span class="line">    for ($i=1; $i&lt;count($array); $i++)&#123;</span><br><span class="line">        if ($array[$i] &lt;= $key)</span><br><span class="line">            $left_arr[] = $array[$i];</span><br><span class="line">        else</span><br><span class="line">            $right_arr[] = $array[$i];</span><br><span class="line">    &#125;</span><br><span class="line">    $left_arr = quick_sort($left_arr);</span><br><span class="line">    $right_arr = quick_sort($right_arr);</span><br><span class="line">    return array_merge($left_arr, array($key), $right_arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-二分查找"><a href="#3-二分查找" class="headerlink" title="3.二分查找"></a>3.二分查找</h2><p><a href="https://blog.csdn.net/nuli888/article/details/52144044" target="_blank" rel="noopener">php二分查找、顺序查找算法</a></p>
<hr>
<h2 id="4-查找算法-KMP"><a href="#4-查找算法-KMP" class="headerlink" title="4.查找算法 KMP"></a>4.查找算法 KMP</h2><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">从头到尾彻底理解KMP</a></p>
<hr>
<h2 id="5-深度、广度优先搜索"><a href="#5-深度、广度优先搜索" class="headerlink" title="5.深度、广度优先搜索"></a>5.深度、广度优先搜索</h2><p><a href="https://www.jianshu.com/p/b086986969e6" target="_blank" rel="noopener">DFS（深度优先搜索）和BFS(广度优先搜索)</a><br><a href="https://juejin.im/post/5a32688b5188254dd9366d6a" target="_blank" rel="noopener">图的广度优先和深度优先遍历（BFS和DFS）</a><br><a href="http://www.blogjava.net/fancydeepin/archive/2013/02/03/395073.html" target="_blank" rel="noopener">二叉树的深度优先遍历与广度优先遍历 [ C++ 实现 ]</a><br><a href="https://www.cnblogs.com/zemliu/archive/2012/09/24/2700878.html" target="_blank" rel="noopener">PHP 二叉树的深度优先与广度优先遍历</a></p>
<hr>
<h2 id="6-LRU-缓存淘汰算法"><a href="#6-LRU-缓存淘汰算法" class="headerlink" title="6.LRU 缓存淘汰算法"></a>6.LRU 缓存淘汰算法</h2><p><a href="https://blog.csdn.net/youyangyouni/article/details/80988852#commentBox" target="_blank" rel="noopener">LRU算法(php实现)</a></p>
<hr>

      
    </div>

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/01/php算法/" data-id="cjxmd3cd100096vhnoc85ne05" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>








  
    <article id="post-数据结构" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/01/数据结构/" class="article-date">
  <time class="post-time" datetime="2016-08-31T16:00:00.000Z" itemprop="datePublished">
    <span class="post-month">9月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
  </div>

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/01/数据结构/">数据结构</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2016/09/01/数据结构/" class="leancloud_visitors" data-flag-title="数据结构">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><hr>
<h2 id="1-堆、栈特性"><a href="#1-堆、栈特性" class="headerlink" title="1.堆、栈特性"></a>1.堆、栈特性</h2><h3 id="栈：像装数据的桶或箱子"><a href="#栈：像装数据的桶或箱子" class="headerlink" title="栈：像装数据的桶或箱子"></a>栈：像装数据的桶或箱子</h3><p>我们先从大家比较熟悉的栈说起吧，它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。</p>
<p>这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我们首先要移开压在它上面的物体（放入的比较晚的物体）。</p>
<p>百度百科：栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。</p>
<h3 id="堆：像一棵倒过来的树"><a href="#堆：像一棵倒过来的树" class="headerlink" title="堆：像一棵倒过来的树"></a>堆：像一棵倒过来的树</h3><p>而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。</p>
<p>通常我们所说的堆的数据结构，是指二叉堆。</p>
<p>堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。</p>
<p>由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>
<p>百度百科：堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p>
<p>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>
<h3 id="堆和栈的区别可以引用一位前辈的比喻来看出："><a href="#堆和栈的区别可以引用一位前辈的比喻来看出：" class="headerlink" title="堆和栈的区别可以引用一位前辈的比喻来看出："></a>堆和栈的区别可以引用一位前辈的比喻来看出：</h3><p>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 </p>
<p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。比喻很形象，说的很通俗易懂，不知道你是否有点收获。</p>
<hr>
<h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h2><p>队列（queue）是一种采用先进先出(FIFO)策略的抽象数据结构，它的想法来自于生活中排队的策略。顾客在付款结账的时候，按照到来的先后顺序排队结账，先来的顾客先结账，后来的顾客后结账。队列的实现一般有数组实现和链表实现两种方式。<br>队列又分单链队列、循环队列、阵列队列，具体可参见<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">维基</a></p>
<hr>
<h2 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3.哈希表"></a>3.哈希表</h2><p>Hash表也称散列表，也有直接译作哈希表，Hash表是一种特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，通过把关键码值（Key value）映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做Hash函数，存放记录的数组叫做Hash表。</p>
<h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h2><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>

      
    </div>

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/01/数据结构/" data-id="cjxmd3cd6000e6vhnnmcqaw1e" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>








  
    <article id="post-php知识点" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/20/php知识点/" class="article-date">
  <time class="post-time" datetime="2016-07-19T16:00:00.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br>
    <span class="post-day">20</span>
  </time>
</a>
  </div>

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/20/php知识点/">php知识点</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2016/07/20/php知识点/" class="leancloud_visitors" data-flag-title="php知识点">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="php知识点"><a href="#php知识点" class="headerlink" title="php知识点"></a>php知识点</h1><hr>
<h2 id="1-普通字符串处理函数和mb-系列函数的区别："><a href="#1-普通字符串处理函数和mb-系列函数的区别：" class="headerlink" title="1.普通字符串处理函数和mb_系列函数的区别："></a>1.普通字符串处理函数和mb_系列函数的区别：</h2><p>不同编码的个别语言（比如中文）所占字节数不同，<br>一个汉字在GB2312编码下占2个字节，在UTF-8（是变长编码）编码下占2-3个字节，<br>普通字符串处理函数是按每个字符1字节来处理的，<br>而mb_系列的函数在使用时可以多指定一个编码参数，<br>方便处理不同编码的中文。<br>最简单的例子，strlen() 会返回一个字符串所占字节数，<br>而mb_strlen()会返回一个字符串的字符数。<br>再比如，substr($str2, 2, 2)在$str为中文时可能会正好截取到一个汉字的一部分，<br>这时就会发生乱码，而mb_substr($str, 2, 2, ‘utf-8’)指定编码后就不会发生乱码问题了，<br>中文时即是取几个汉字。</p>
<hr>
<h2 id="2-amp-引用，结合案例分析"><a href="#2-amp-引用，结合案例分析" class="headerlink" title="2.&amp; 引用，结合案例分析"></a>2.&amp; 引用，结合案例分析</h2><p>PHP 的引用允许用两个变量来指向同一个内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$a = &amp; $b;</span><br></pre></td></tr></table></figure>
<p>$a 和 $b 在这里是完全相同的，<br>这并不是 $a 指向了 $b 或者相反，而是 $a 和 $b 指向了同一个地方。</p>
<p>引用做的第二件事是用引用传递变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(&amp; $var) &#123;</span><br><span class="line">  $var++;</span><br><span class="line">&#125;</span><br><span class="line">$a = 5;</span><br><span class="line">foo($a);</span><br></pre></td></tr></table></figure>
<p>将使 $a 变成 6。这是因为在 foo 函数中变量 $var 指向了和 $a 指向的同一个内容。</p>
<p>引用不是指针，下面的结构不会产生预期的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(&amp; $var) &#123;</span><br><span class="line">  $var = &amp; $GLOBALS[&quot;baz&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo($bar);</span><br></pre></td></tr></table></figure>
<p>当 unset 一个引用，只是断开了变量名和变量内容之间的绑定。<br>这并不意味着变量内容被销毁了。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = 1;</span><br><span class="line">$b =&amp; $a;</span><br><span class="line">unset($a);</span><br></pre></td></tr></table></figure>
<p>不会 unset  $b，只是 $a。</p>
<hr>
<h2 id="3-与-区别"><a href="#3-与-区别" class="headerlink" title="3.== 与 === 区别"></a>3.== 与 === 区别</h2><p>==  是不带类型比较是否相同（比如数字100 == ‘100’结果为true）</p>
<p>=== 是带类型比较是否相同（比如100 == ‘100’结果为false）</p>
<hr>
<h2 id="4-isset-与-empty-区别"><a href="#4-isset-与-empty-区别" class="headerlink" title="4.isset 与 empty 区别"></a>4.isset 与 empty 区别</h2><h3 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h3><p>empty()：如果变量是非空或非零的值，则返回false。</p>
<p>“”、0、”0”、NULL、FALSE、array()、var $var、未定义，没有任何属性的对象，则返回false。</p>
<p>如果var为空，则返回true。</p>
<h3 id="isset"><a href="#isset" class="headerlink" title="isset()"></a>isset()</h3><p>isset()：如果变量存在（非null）则返回true，否则返回false。</p>
<p>变量值设置为：null，返回也是false; </p>
<p>unset一个变量后，变量被取消了。注意，isset对于NULL值变量，特殊处理。</p>
<h3 id="is-null"><a href="#is-null" class="headerlink" title="is_null()"></a>is_null()</h3><p>is_null()：检测传入值【值，变量，表达式】是否是null。<br>只有一个变量定义了，且它的值是null，它才返回TRUE。其它都返回 FALSE 【未定义变量传入后会出错！】。</p>
<h3 id="defined"><a href="#defined" class="headerlink" title="defined()"></a>defined()</h3><p>defined()：检测一个常量是否已经定义</p>
<h3 id="property-exists"><a href="#property-exists" class="headerlink" title="property_exists()"></a>property_exists()</h3><p>property_exists()：检测一个类(或对象)中是否存在某一个属性，跟array_key_exists()一样，即使属性值为null，仍然返回true。</p>
<hr>
<h2 id="5-全部魔术函数理解"><a href="#5-全部魔术函数理解" class="headerlink" title="5.全部魔术函数理解"></a>5.全部魔术函数理解</h2><h3 id="1-construct"><a href="#1-construct" class="headerlink" title="1. __construct"></a>1. __construct</h3><p>类的构造函数，常用来给类的属性赋值。</p>
<p>注意事项：<br>如果子类中定义了构造函数则不会隐式调用其父类的构造函数。<br>要执行父类的构造函数，<br>需要在子类的构造函数中调用 parent::__construct()，<br>如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。</p>
<h3 id="2-destruct"><a href="#2-destruct" class="headerlink" title="2. __destruct"></a>2. __destruct</h3><p>析构函数，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p>
<h3 id="3-call，callStatic"><a href="#3-call，callStatic" class="headerlink" title="3. call，callStatic"></a>3. <strong>call，</strong>callStatic</h3><p>在对象中调用一个不可访问方法时，__call() 会被调用。</p>
<p>在静态上下文中调用一个不可访问方法时，<br>__callStatic() 会被调用，<br>作为调用类中不存在的方法时对开发者的一个友好提示。</p>
<h3 id="4-set，get，isset-，unset"><a href="#4-set，get，isset-，unset" class="headerlink" title="4. set，get，isset ，unset"></a>4. <strong>set，</strong>get，<strong>isset ，</strong>unset</h3><p>在给不可访问属性赋值时，__set() 会被调用；</p>
<p>读取不可访问属性的值时，__get() 会被调用；</p>
<p>当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用；</p>
<p>当对不可访问属性调用 unset() 时，__unset() 会被调用。</p>
<h3 id="5-sleep，wakeup-serialize"><a href="#5-sleep，wakeup-serialize" class="headerlink" title="5. sleep，wakeup  serialize()"></a>5. <strong>sleep，</strong>wakeup  serialize()</h3><p>函数会检查类中是否存在一个魔术方法 __sleep()。</p>
<p>如果存在，该方法会先被调用，然后才执行序列化操作。</p>
<p>此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</p>
<p>如果该方法未返回任何内容，<br>则 NULL 被序列化，<br>并产生一个 E_NOTICE 级别的错误，<br>返回父类的私有成员的名字，<br>常用于提交未提交的数据，或类似的清理操作。</p>
<p>与之相反，unserialize() 会检查是否存在一个 <strong>wakeup() 方法。<br>如果存在，则会先调用 </strong>wakeup 方法，<br>预先准备对象需要的资源。__wakeup() 经常用在反序列化操作中，<br>例如重新建立数据库连接，或执行其它初始化操作。</p>
<h3 id="6-toString"><a href="#6-toString" class="headerlink" title="6. __toString"></a>6. __toString</h3><p>用于当直接echo $obj（一个对象）时该显示什么内容，必须返回一个字符串且不能在方法内抛出异常。</p>
<h3 id="7-invoke"><a href="#7-invoke" class="headerlink" title="7. __invoke"></a>7. __invoke</h3><p>当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function __invoke($x) &#123;</span><br><span class="line">  var_dump($x);</span><br><span class="line">&#125; </span><br><span class="line">$obj = new CallableClass;</span><br><span class="line">$obj(5);会输出int(5)</span><br></pre></td></tr></table></figure>
<h3 id="8-set-state"><a href="#8-set-state" class="headerlink" title="8. __set_state"></a>8. __set_state</h3><p>调用 var_export() 导出类时，此静态 方法会被调用。</p>
<p>本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。</p>
<h3 id="9-clone"><a href="#9-clone" class="headerlink" title="9. __clone"></a>9. __clone</h3><p>对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。</p>
<p>对象中的 __clone() 方法不能被直接调用。</p>
<h3 id="10-copy-of-object-clone-object"><a href="#10-copy-of-object-clone-object" class="headerlink" title="10. $copy_of_object = clone $object;"></a>10. $copy_of_object = clone $object;</h3><p>当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。<br>所有的引用属性 仍然会是一个指向原来的变量的引用。<br>当复制完成时，如果定义了 <strong>clone() 方法，<br>则新创建的对象（复制生成的对象）中的 </strong>clone() 方法会被调用，<br>可用于修改属性的值（如果有必要的话）。</p>
<h3 id="11-debugInfo"><a href="#11-debugInfo" class="headerlink" title="11. __debugInfo"></a>11. __debugInfo</h3><p>当var_dumo(new Class)（参数为一个对象时），<br>该方法可以控制显示的内容，<br>若没有定义此方法，<br>var_dump()将默认展示对象的所有属性和方法。</p>
<hr>
<h2 id="6-static、-this、self-区别"><a href="#6-static、-this、self-区别" class="headerlink" title="6.static、$this、self 区别"></a>6.static、$this、self 区别</h2><p>$this通俗解释就是当前类的一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  public static function className() &#123;</span><br><span class="line">    echo __CLASS__;</span><br><span class="line">  &#125;</span><br><span class="line">  public static function test() &#123;</span><br><span class="line">    self::className();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  public static function className()&#123;</span><br><span class="line">    echo __CLASS__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test(); //这将打印出来A</span><br></pre></td></tr></table></figure>
<p>另一方面static::它具有预期的行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  public static function className() &#123;</span><br><span class="line">    echo __CLASS__;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static function test() &#123;</span><br><span class="line">    static::className();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  public static function className() &#123;</span><br><span class="line">    echo __CLASS__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test(); // 这将打印出来B</span><br></pre></td></tr></table></figure>
<p>这在PHP 5.3.0中称为后期静态绑定。它解决了调用运行时引用的类的限制。</p>
<hr>
<h2 id="7-private、protected、public、final-区别"><a href="#7-private、protected、public、final-区别" class="headerlink" title="7.private、protected、public、final 区别"></a>7.private、protected、public、final 区别</h2><p>public:权限是最大的，可以内部调用，实例调用等。</p>
<p>protected: 受保护类型，用于本类和继承此类的子类调用。</p>
<p>private: 私有类型，只有在本类中使用。</p>
<p>static：静态资源，可以被子类继承。</p>
<p>abstract：修饰抽象方法，没有方法体，由继承该类的子类来实现。</p>
<p>final：表示该变量、该方法已经“完成”，不可被覆盖。修饰类时该类不能被继承。 </p>
<p>（因此final和abstract不能同时出现）</p>
<hr>
<h2 id="8-OOP思想"><a href="#8-OOP思想" class="headerlink" title="8.OOP思想"></a>8.OOP思想</h2><p>简单理解：</p>
<p>面向对象的编程就是编出一个人来，<br>这个人可以做很多种动作，跑，跳，走，举手…<br>他能做什么取决于你如何组合这些动作，<br>有些动作在一些功能中是不用的。</p>
<p>而层次化的编程（面向过程）就是造出一个具体的工具，<br>他只能干这样一件事，条件——结果。</p>
<hr>
<h2 id="9-抽象类、接口-分别使用场景"><a href="#9-抽象类、接口-分别使用场景" class="headerlink" title="9.抽象类、接口 分别使用场景"></a>9.抽象类、接口 分别使用场景</h2><p>接口 通常是为了抽象一种行为，<br>接口是一种规范，<br>在设计上的意义是为了功能模块间的解耦，<br>方便后面的功能扩展、维护，接口不能有具体的方法。</p>
<p>抽象类 可以有具体的方法，<br>也可以有抽象方法，<br>一旦一个类有抽象方法，<br>这个类就必须声明为抽象类，<br>很多时候是为子类提供一些共用方法。</p>
<p>所以，抽象类是为了简化接口的实现，<br>他不仅提供了公共方法的实现，<br>让你可以快速开发，<br>又允许你的类完全可以自己实现所有的方法，<br>不会出现紧耦合的问题。</p>
<p>应用场合很简单了</p>
<p>1 优先定义接口</p>
<p>2 如果有多个接口实现有公用的部分，则使用抽象类，然后集成它。</p>
<p>举个简单的例子：<br>有一个动物接口，<br>内有动物叫声和动物说你好两个方法，<br>在实现该接口时各个动物的叫声肯定是不同的，<br>但是他们都在说你好是相同的，<br>此时就可以用抽象类，<br>把相同的说你好的方法抽象出去，<br>就不用在每个动物类中写了。</p>
<hr>
<h2 id="10-Trait-是什么东西"><a href="#10-Trait-是什么东西" class="headerlink" title="10.Trait 是什么东西"></a>10.Trait 是什么东西</h2><p>Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。</p>
<p>Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。</p>
<p>Trait 和 Class 组合的语义定义了一种减少复杂性的方式，</p>
<p>避免传统多继承和 Mixin 类相关典型问题。</p>
<p>Trait 和 Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。<br>无法通过 trait 自身来实例化。<br>它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。</p>
<p>简单理解：<br>Trait为不支持多继承的php实现了多继承，<br>使用时不是用extends继承，<br>而是在类内部用 use 类名 表示。</p>
<p>重名方法优先级问题：<br>当前类的成员覆盖 trait 的方法，而 trait 则覆盖被继承的方法。</p>
<hr>
<h2 id="11-echo、print、print-r-区别-区分出表达式与语句的区别-："><a href="#11-echo、print、print-r-区别-区分出表达式与语句的区别-：" class="headerlink" title="11.echo、print、print_r 区别(区分出表达式与语句的区别)："></a>11.echo、print、print_r 区别(区分出表达式与语句的区别)：</h2><p>echo，print是语言结构，print_r和var_dump是常规功能。</p>
<p>print并且echo或多或少相同; 它们都是显示字符串的语言结构。<br>差异很微妙：print返回值为1，因此可以在表达式中使用，但echo具有void返回类型。<br>echo可以采用多个参数，尽管这种用法很少见;<br>echo比print快一点。（就个人而言，我总是使用echo，从不print。）</p>
<p>var_dump打印出变量的详细转储，包括其类型大小和任何子项的类型和大小（如果它是数组或对象）。</p>
<p>print_r以更易于阅读的格式化形式打印变量（数组或对象）：<br>不能传递字符串，它省略了类型信息，不给出数组大小等。</p>
<p>var_dump， print_r根据我的经验，通常在调试时更有用。<br>当您不确切知道变量中的值/类型时，它尤其有用。考虑这个测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$values = array(0, 0.0, false, &apos;&apos;);</span><br><span class="line"></span><br><span class="line">var_dump($values);</span><br><span class="line"></span><br><span class="line">print_r ($values);</span><br><span class="line"></span><br><span class="line">随着print_r你不能告诉之间的区别0和0.0，或false和&apos;&apos;：</span><br><span class="line"></span><br><span class="line">array(4) &#123;</span><br><span class="line"></span><br><span class="line">  [0]=&gt;  int(0)</span><br><span class="line"></span><br><span class="line">  [1]=&gt;  float(0)</span><br><span class="line"></span><br><span class="line">  [2]=&gt;  bool(false)</span><br><span class="line"></span><br><span class="line">  [3]=&gt;  string(0) &quot;&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array(</span><br><span class="line"></span><br><span class="line">    [0] =&gt; 0</span><br><span class="line"></span><br><span class="line">    [1] =&gt; 0</span><br><span class="line"></span><br><span class="line">    [2] =&gt;</span><br><span class="line"></span><br><span class="line">    [3] =&gt; )</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="12-construct-与-destruct-区别"><a href="#12-construct-与-destruct-区别" class="headerlink" title="12.construct 与 destruct 区别"></a>12.<strong>construct 与 </strong>destruct 区别</h2><p>在一个类中定义一个方法作为构造函数。</p>
<p>具有构造函数的类会在每次创建新对象时先调用此方法，<br>所以非常适合在使用对象之前做一些初始化工作。</p>
<p>析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p>
<p>和构造函数一样，父类的析构函数不会被引擎暗中调用。</p>
<p>要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct()。</p>
<p>此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。</p>
<p>析构函数即使在使用 exit() 终止脚本运行时也会被调用。</p>
<p>在析构函数中调用 exit() 将会中止其余关闭操作的运行。</p>
<hr>
<h2 id="13-static-作用（区分类与函数内）手册-、SOF"><a href="#13-static-作用（区分类与函数内）手册-、SOF" class="headerlink" title="13.static 作用（区分类与函数内）手册 、SOF"></a>13.static 作用（区分类与函数内）手册 、SOF</h2><p>声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。<br>为了兼容 PHP 4，如果没有指定访问控制，属性和方法默认为公有。<br>由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。<br>静态属性不可以由对象通过 -&gt; 操作符来访问，但可以由对象通过 :: 来访问<br>用静态方式调用一个非静态方法会导致一个 E_STRICT 级别的错误。<br>就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。<br>也可以用一个值等于类名的字符串变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static，比如有个class A{}， 则可以用$a=’A’; $a::这样调用<br>在类之外（即：在函数中），static变量是在函数退出时不会丢失其值的变量。在同一函数的不同调用中维护的变量只有一个值。从PHP手册的例子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line"></span><br><span class="line">    static $a = 0;</span><br><span class="line"></span><br><span class="line">    echo $a;</span><br><span class="line"></span><br><span class="line">    $a++;&#125;</span><br><span class="line"></span><br><span class="line">test();  // prints 0</span><br><span class="line"></span><br><span class="line">test();  // prints 1</span><br><span class="line"></span><br><span class="line">test();  // prints 2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="14-toString-作用"><a href="#14-toString-作用" class="headerlink" title="14.__toString() 作用"></a>14.__toString() 作用</h2><p>用于一个类被当成字符串时应怎样回应。</p>
<p>例如 echo $obj; （$obj为一个对象） 应该显示些什么。</p>
<p>此方法必须返回一个字符串，否则将发出一条E_RECOVERABLE_ERROR 级别的致命错误。</p>
<p>类似与Java的toString方法。</p>
<hr>
<h2 id="15-单引号’与双引号”区别"><a href="#15-单引号’与双引号”区别" class="headerlink" title="15.单引号’与双引号”区别"></a>15.单引号’与双引号”区别</h2><p>单引号字符串几乎完全“按原样”显示。变量和大多数转义序列都不会被解释。例外情况是，要显示单引号字符，必须使用反斜杠\’转义它，要显示反斜杠字符，必须使用另一个反斜杠转义它\。</p>
<p>双引号字符串将显示一系列转义字符（包括一些正则表达式），并且将解析字符串中的变量。这里重要的一点是，您可以使用花括号来隔离要解析的变量的名称。例如，假设您有变量$type，那么您echo “The $type are”将查找该变量$type。绕过这个用途echo “The {$type} are”您可以在美元符号之前或之后放置左括号。看一下字符串解析，看看如何使用数组变量等。</p>
<p>Heredoc字符串语法就像双引号字符串一样。它始于&lt;&lt;&lt;。在此运算符之后，提供标识符，然后提供换行符。字符串本身如下，然后再次使用相同的标识符来关闭引号。您不需要在此语法中转义引号。</p>
<p>Nowdoc（自PHP 5.3.0开始）字符串语法基本上类似于单引号字符串。不同之处在于，甚至不需要转义单引号或反斜杠。nowdoc用与heredocs相同的&lt;&lt;&lt;序列标识，但后面的标识符用单引号括起来，例如&lt;&lt;&lt;’EOT’。在nowdoc中没有解析。</p>
<hr>
<h2 id="16-常见-HTTP-状态码，分别代表什么含义，301-什么意思-404-呢"><a href="#16-常见-HTTP-状态码，分别代表什么含义，301-什么意思-404-呢" class="headerlink" title="16.常见 HTTP 状态码，分别代表什么含义，301 什么意思 404 呢?"></a>16.常见 HTTP 状态码，分别代表什么含义，301 什么意思 404 呢?</h2><p>1xx消息：这一类型的状态码，代表请求已被接受，需要继续处理。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。<br>2xx成功：这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。<br>200 OK：请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。<br>202 Accepted：服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。<br>204 No Content：服务器成功处理了请求，没有返回任何内容。<br>3xx重定向：这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。<br>301 Moved Permanently：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。<br>4xx客户端错误：这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。<br>400 Bad Request：由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。<br>401 Unauthorized：类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。[32]该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。<br>403 Forbidden：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。<br>404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。[35]没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。<br>405 Method Not Allowed：请求行中指定的请求方法不能被用于请求相应的资源。<br>408 Request Timeout：请求超时。<br>5xx服务器错误：表示服务器无法完成明显有效的请求。[56]这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。<br>500 Internal Server Error：通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。<br>502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>503 Service Unavailable：由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。<br>504 Gateway Timeout：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器在DNS查询超时时会返回400或者500错误。  </p>
<hr>
<h2 id="17-autoload、composer-原理-PSR-4-、原理"><a href="#17-autoload、composer-原理-PSR-4-、原理" class="headerlink" title="17.__autoload、composer 原理 PSR-4 、原理"></a>17.__autoload、composer 原理 PSR-4 、原理</h2><p>autoload机制可以使得PHP程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为lazy loading(懒加载)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function __autoload($classname)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  $classpath=&quot;./&quot;.$classname.&apos;.class.php&apos;;</span><br><span class="line"></span><br><span class="line">  if(file_exists($classpath))</span><br><span class="line"></span><br><span class="line">  &#123;    require_once($classpath);  &#125;</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line"></span><br><span class="line">  &#123;    echo &apos;class file&apos;.$classpath.&apos;not found!&apos;;   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> $person = new Person(”Altair”, 6);</span><br><span class="line"></span><br><span class="line"> var_dump ($person);</span><br></pre></td></tr></table></figure>
<p>通常PHP在使用一个类时，如果发现这个类没有加载，就会自动运行__autoload()函数，在这个函数中我们可以加载需要使用的类。</p>
<p><strong>autoload()至少要做三件事，<br>1：根据类名确定类文件名。<br>2：确定类文件所在的磁盘路径(类与调用它们的PHP程序文件在同一个文件夹下)。<br>3：将类从磁盘文件中加载到系统中(php7.2废除</strong>autoload函数，建议使用spl_autoload_register() 实现相同功能)  </p>
<p>Autoload原理简单概述：<br>1：检查执行器全局变量函数指针autoload_func是否为NULL。<br>2：如果autoload_func==NULL, 则查找系统中是否定义有<strong>autoload()函数，如果没有，则报告错误并退出。<br>3：如果定义了</strong>autoload()函数，则执行<strong>autoload()尝试加载类，并返回加载结果。<br>4：如果autoload_func不为NULL，则直接执行autoload_func指针指向的函数用来加载类。注意此时并不检查</strong>autoload()函数是否定义。  </p>
<p>spl_autoload_register()就是我们上面所说的__autoload调用堆栈，<br>我们可以向这个函数注册多个我们自己的 autoload() 函数，<br>当 PHP 找不到类名时，PHP就会调用这个堆栈，然后去调用自定义的 autoload() 函数，实现自动加载功能。<br>如果我们不向这个函数输入任何参数，那么就会默认注册 spl_autoload() 函数。</p>
<p>composer 做了哪些事情：你有一个项目依赖于若干个库；其中一些库依赖于其他库；你声明你所依赖的东西；composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。</p>
<p>执行 composer require 时发生了什么：composer 会找到符合 PR4 规范的第三方库的源；<br>将其加载到 vendor 目录下；初始化顶级域名的映射并写入到指定的文件里；<br>写好一个 autoload 函数，并且注册到 spl_autoload_register()里。</p>
<p>composer是利用的遵循psr-4规范的类自动加载机制实现的，PSR-4规范简介：<br>1:完整的类名 必须 要有一个顶级命名空间，被称为 “vendor namespace”；<br>2:完整的类名 可以 有一个或多个子命名空间；<br>3:完整的类名 必须 有一个最终的类名；<br>4:完整的类名 中任意一部分中的下滑线都是没有特殊含义的；<br>5:完整的类名 可以 由任意大小写字母组成；<br>6:所有类名都 必须 是大小写敏感的。<br>7:完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为「命名空间前缀」，其必须与至少一个「文件基目录」相对应；<br>8:紧接命名空间前缀后的子命名空间 必须 与相应的「文件基目录」相匹配，其中的命名空间分隔符将作为目录分隔符。<br>9:末尾的类名 必须 与对应的以 .php 为后缀的文件同名。<br>10:自动加载器（autoloader）的实现 一定不可 抛出异常、一定不可 触发任一级别的错误信息以及 不应该 有返回值。</p>
<p>composer自动加载原理概述：<br>如果我们在代码中写下 new phpDocumentor\Reflection\Element()，<br>PHP 会通过 SPL_autoload_register 调用 loadClass -&gt; findFile -&gt; findFileWithExtension。<br>步骤如下：</p>
<p>将 \ 转为文件分隔符/，加上后缀php，变成 $logicalPathPsr4, 即 phpDocumentor/Reflection//Element.php;<br>利用命名空间第一个字母p作为前缀索引搜索 prefixLengthsPsr4 数组，查到下面这个数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;p&apos; =&gt;</span><br><span class="line">    array (</span><br><span class="line">        &apos;phpDocumentor\\Reflection\\&apos; =&gt; 25,</span><br><span class="line">        &apos;phpDocumentor\\Fake\\&apos; =&gt; 19,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>遍历这个数组，得到两个顶层命名空间 phpDocumentor\Reflection\ 和 phpDocumentor\Fake\</p>
<p>在这个数组中查找 phpDocumentor\Reflection\Element，找出 phpDocumentor\Reflection\ 这个顶层命名空间并且长度为25。<br>在prefixDirsPsr4 映射数组中得到phpDocumentor\Reflection\ 的目录映射为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;phpDocumentor\\Reflection\\&apos; =&gt;</span><br><span class="line">    array (</span><br><span class="line">        0 =&gt; __DIR__ . &apos;/..&apos; . &apos;/phpdocumentor/reflection-common/src&apos;,</span><br><span class="line">        1 =&gt; __DIR__ . &apos;/..&apos; . &apos;/phpdocumentor/type-resolver/src&apos;,</span><br><span class="line">        2 =&gt; __DIR__ . &apos;/..&apos; . &apos;/phpdocumentor/reflection-docblock/src&apos;,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>遍历这个映射数组，得到三个目录映射；<br>查看 “目录+文件分隔符//+substr($logicalPathPsr4, $length)”文件是否存在，存在即返回。这里就是<br>‘<strong>DIR</strong>/../phpdocumentor/reflection-common/src + substr(phpDocumentor/Reflection/Element.php,25)’<br>如果失败，则利用 fallbackDirsPsr4 数组里面的目录继续判断是否存在文件。</p>
<hr>
<h2 id="18-session-共享、存活时间"><a href="#18-session-共享、存活时间" class="headerlink" title="18.session 共享、存活时间"></a>18.session 共享、存活时间</h2><h3 id="为什么要使用Session共享："><a href="#为什么要使用Session共享：" class="headerlink" title="为什么要使用Session共享："></a>为什么要使用Session共享：</h3><p>分布式开发项目中，用户通过浏览器登录商城，实际上会被转发到不同的服务器，当用户登录进入服务器A,session保存了用户的信息，用户再次点击页面被转发到服务器B,这时问题来了，服务器B没有该用户的session信息，无法验证通过，用户被踢回到登录页面，这样体验效果非常不好，甚至无法验证用户，购物车里面商品都不存在了。</p>
<h3 id="利用Redis实现简单的Session共享："><a href="#利用Redis实现简单的Session共享：" class="headerlink" title="利用Redis实现简单的Session共享："></a>利用Redis实现简单的Session共享：</h3><p>1：用户第一次进入商城首页，给一个CSESSIONID,(不用JSESSIONID的原因)，用户添加商品，各种需要记录的操作，都与这个CSESSIONID关联起来；<br>2：当使用登录操作时候，将这个用户的信息，如用户名等存入到redis中，通过K_V，将CSESSIONID加一个标志作为key,将用户信息作为value；<br>3：当用户点击页面被转发到其他服务器时候，在需要验证是否同一个用户时，就可以从redis中取出value,进行验证用户信息，实现共享。  </p>
<h3 id="Session-在php配置文件中的默认有效时间是24分钟，设置session永久有效的方法："><a href="#Session-在php配置文件中的默认有效时间是24分钟，设置session永久有效的方法：" class="headerlink" title="Session 在php配置文件中的默认有效时间是24分钟，设置session永久有效的方法："></a>Session 在php配置文件中的默认有效时间是24分钟，设置session永久有效的方法：</h3><p>1：把“session.use_cookies”设置为1，打开Cookie储存SessionID，不过默认就是1，一般不用修改；<br>2：把“session.cookie_lifetime”改为正无穷（当然没有正无穷的参数，不过999999999和正无穷也没有什么区别）;<br>3：把“session.gc_maxlifetime”设置为和“session.cookie_lifetime”一样的时间；  </p>
<hr>
<h2 id="19-异常处理"><a href="#19-异常处理" class="headerlink" title="19.异常处理"></a>19.异常处理</h2><p>异常处理用于在指定的错误（异常）情况发生时改变脚本的正常流程。这种情况称为异常。  </p>
<h3 id="异常的简单使用："><a href="#异常的简单使用：" class="headerlink" title="异常的简单使用："></a>异常的简单使用：</h3><p>抛出一个异常throw new Exception(“Value must be 1 or below”)，同时不去捕获它，服务器会报Fatal error: Uncaught exception ‘Exception’ 的错误；</p>
<p>抛出一个异常throw new Exception(“Value must be 1 or below”)，<br>并try{} catch(Exception $e){echo:’Message:’ . $e-&gt;getMessage();}，<br>当异常发生时，服务器就会报预设的错误提示：Message: Value must be 1 or below。</p>
<p>自定义Exception类：必须继承Exception类，可以使用Exception类的所有方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class customException extends Exception</span><br><span class="line">&#123;</span><br><span class="line">    public function errorMessage() &#123;</span><br><span class="line">        //error message</span><br><span class="line">        $errorMsg = &apos;Error on line &apos;.$this-&gt;getLine().&apos; in &apos;.$this-&gt;getFile().&apos;: &lt;b&gt;&apos;.$this-&gt;getMessage().&apos;&lt;/b&gt; is not a valid E-Mail address&apos;;</span><br><span class="line">        return $errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常的规则："><a href="#异常的规则：" class="headerlink" title="异常的规则："></a>异常的规则：</h3><p>需要进行异常处理的代码应该放入 try 代码块内，以便捕获潜在的异常。</p>
<p>每个 try 或 throw 代码块必须至少拥有一个对应的 catch 代码块。</p>
<p>使用多个 catch 代码块可以捕获不同种类的异常。</p>
<p>可以在 try 代码块内的 catch 代码块中再次抛出（re-thrown）异常。</p>
<p>简而言之：如果抛出了异常，就必须捕获它</p>
<hr>
<h2 id="20-如何-foreach-迭代对象"><a href="#20-如何-foreach-迭代对象" class="headerlink" title="20.如何 foreach 迭代对象"></a>20.如何 foreach 迭代对象</h2><p>展示foreach工作原理的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class myIterator implements Iterator &#123;</span><br><span class="line">    private $position = 0;</span><br><span class="line">    private $array = array(</span><br><span class="line">        &quot;firstelement&quot;,</span><br><span class="line">        &quot;secondelement&quot;,</span><br><span class="line">        &quot;lastelement&quot;,</span><br><span class="line">    );  </span><br><span class="line"></span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        $this-&gt;position = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回到迭代器的第一个元素</span><br><span class="line">    function rewind() &#123;</span><br><span class="line">        var_dump(__METHOD__);</span><br><span class="line">        $this-&gt;position = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回当前元素</span><br><span class="line">    function current() &#123;</span><br><span class="line">        var_dump(__METHOD__);</span><br><span class="line">        return $this-&gt;array[$this-&gt;position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回当前元素的键</span><br><span class="line">    function key() &#123;</span><br><span class="line">        var_dump(__METHOD__);</span><br><span class="line">        return $this-&gt;position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //向前移动到下一个元素</span><br><span class="line">    function next() &#123;</span><br><span class="line">        var_dump(__METHOD__);</span><br><span class="line">        ++$this-&gt;position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //检查当前位置是否有效</span><br><span class="line">    function valid() &#123;</span><br><span class="line">        var_dump(__METHOD__);</span><br><span class="line">        return isset($this-&gt;array[$this-&gt;position]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$it = new myIterator;</span><br><span class="line">foreach($it as $key =&gt; $value) &#123;</span><br><span class="line">    var_dump($key, $value);</span><br><span class="line">    echo &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">string(18) &quot;myIterator::rewind&quot;</span><br><span class="line">string(17) &quot;myIterator::valid&quot;</span><br><span class="line">string(19) &quot;myIterator::current&quot;</span><br><span class="line">string(15) &quot;myIterator::key&quot;</span><br><span class="line"></span><br><span class="line">int(0)</span><br><span class="line">string(12) &quot;firstelement&quot;</span><br><span class="line">string(16) &quot;myIterator::next&quot;</span><br><span class="line">string(17) &quot;myIterator::valid&quot;</span><br><span class="line">string(19) &quot;myIterator::current&quot;</span><br><span class="line">string(15) &quot;myIterator::key&quot;</span><br><span class="line"></span><br><span class="line">int(1)</span><br><span class="line">string(13) &quot;secondelement&quot;</span><br><span class="line">string(16) &quot;myIterator::next&quot;</span><br><span class="line">string(17) &quot;myIterator::valid&quot;</span><br><span class="line">string(19) &quot;myIterator::current&quot;</span><br><span class="line">string(15) &quot;myIterator::key&quot;</span><br><span class="line"></span><br><span class="line">int(2)</span><br><span class="line">string(11) &quot;lastelement&quot;</span><br><span class="line">string(16) &quot;myIterator::next&quot;</span><br><span class="line">string(17) &quot;myIterator::valid&quot;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="21-如何数组化操作对象-obj-key"><a href="#21-如何数组化操作对象-obj-key" class="headerlink" title="21.如何数组化操作对象 $obj[key];"></a>21.如何数组化操作对象 $obj[key];</h2><p>PHP提供了ArrayAccess接口使实现此接口的类的实例可以向操作数组一样通过$obj[key]来操作，<br>以下是php手册中对实现ArrayAccess接口的类的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class obj implements arrayaccess &#123;</span><br><span class="line">    private $container = array();</span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        $this-&gt;container = array(</span><br><span class="line">            &quot;one&quot;   =&gt; 1,</span><br><span class="line">            &quot;two&quot;   =&gt; 2,</span><br><span class="line">            &quot;three&quot; =&gt; 3,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置一个偏移位置的值</span><br><span class="line">    public function offsetSet($offset, $value) &#123;</span><br><span class="line">        if (is_null($offset)) &#123;</span><br><span class="line">            $this-&gt;container[] = $value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;container[$offset] = $value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //检查一个偏移位置是否存在</span><br><span class="line">    public function offsetExists($offset) &#123;</span><br><span class="line">        return isset($this-&gt;container[$offset]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //复位一个偏移位置的值</span><br><span class="line">    public function offsetUnset($offset) &#123;</span><br><span class="line">        unset($this-&gt;container[$offset]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取一个偏移位置的值</span><br><span class="line">    public function offsetGet($offset) &#123;</span><br><span class="line">        return isset($this-&gt;container[$offset]) ? $this-&gt;</span><br><span class="line"></span><br><span class="line">        container[$offset] : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对该类测试使用：</span><br><span class="line"></span><br><span class="line">$obj = new obj;</span><br><span class="line">var_dump(isset($obj[&quot;two&quot;]));</span><br><span class="line">var_dump($obj[&quot;two&quot;]);</span><br><span class="line">unset($obj[&quot;two&quot;]);</span><br><span class="line">var_dump(isset($obj[&quot;two&quot;]));</span><br><span class="line">$obj[&quot;two&quot;] = &quot;A value&quot;;</span><br><span class="line">var_dump($obj[&quot;two&quot;]);</span><br><span class="line">$obj[] = &apos;Append 1&apos;;</span><br><span class="line">$obj[] = &apos;Append 2&apos;;</span><br><span class="line">$obj[] = &apos;Append 3&apos;;</span><br><span class="line">print_r($obj);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">以上例程的输出类似于：</span><br><span class="line"></span><br><span class="line">bool(true)</span><br><span class="line">int(2)</span><br><span class="line">bool(false)</span><br><span class="line">string(7) &quot;A value&quot;</span><br><span class="line"></span><br><span class="line">obj Object</span><br><span class="line">(</span><br><span class="line">    [container:obj:private] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [one] =&gt; 1</span><br><span class="line">            [three] =&gt; 3</span><br><span class="line">            [two] =&gt; A value</span><br><span class="line">            [0] =&gt; Append 1</span><br><span class="line">            [1] =&gt; Append 2</span><br><span class="line">            [2] =&gt; Append 3</span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="22-如何函数化对象-obj-123"><a href="#22-如何函数化对象-obj-123" class="headerlink" title="22.如何函数化对象 $obj(123);"></a>22.如何函数化对象 $obj(123);</h2><p>利用PHP提供的魔术函数<strong>invoke()方法可以直接实现，<br>当尝试以调用函数的方式调用一个对象时，
</strong>invoke() 方法会被自动调用，下面是官方手册示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class CallableClass</span><br><span class="line">&#123;</span><br><span class="line">    function __invoke($x) &#123;</span><br><span class="line">        var_dump($x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = new CallableClass;</span><br><span class="line">$obj(5);</span><br><span class="line">var_dump(is_callable($obj));</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">int(5)</span><br><span class="line">bool(true)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="23-yield-是什么，说个使用场景-yield"><a href="#23-yield-是什么，说个使用场景-yield" class="headerlink" title="23.yield 是什么，说个使用场景 yield"></a>23.yield 是什么，说个使用场景 yield</h2><p>PHP官方手册对yield的解释：</p>
<p>它最简单的调用形式看起来像一个return申明，不同之处在于普通return会返回值并终止函数的执行，而yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数。</p>
<p>我的简单理解：yield起一个暂停程序的作用，比如在一个循环中，程序执行遇到yield语句就会返回yield声明的数据，而不是循环完整体返回，加了yield后就会挨个返回。</p>
<p>Caution：如果在一个表达式上下文(例如在一个赋值表达式的右侧)中使用yield，你必须使用圆括号把yield申明包围起来。 例如这样是有效的：$data = (yield $value);</p>
<p>属于PHP生成器语法，官方手册的解释：</p>
<p>一个生成器函数看起来像一个普通的函数，不同的是普通函数返回一个值，而一个生成器可以yield生成许多它所需要的值。</p>
<p>当一个生成器被调用的时候，它返回一个可以被遍历的对象.当你遍历这个对象的时候(例如通过一个foreach循环)，PHP 将会在每次需要值的时候调用生成器函数，并在产生一个值之后保存生成器的状态，这样它就可以在需要产生下一个值的时候恢复调用状态。</p>
<p>一旦不再需要产生更多的值，生成器函数可以简单退出，而调用生成器的代码还可以继续执行，就像一个数组已经被遍历完了。</p>
<p>Note:一个生成器不可以返回值： 这样做会产生一个编译错误。然而return空是一个有效的语法并且它将会终止生成器继续执行。</p>
<p>使用场景：</p>
<p>laravel框架的model以游标方式取数据时，用的是yield来防止一次性取数据太多导致内存不足的问题</p>
<p><a href="https://www.oschina.net/translate/cooperative-multitasking-using-coroutines-in-php" target="_blank" rel="noopener">PHP 使用协同程序实现合作多任务</a></p>
<hr>
<h2 id="24-PSR-是什么，PSR-1-2-4-7"><a href="#24-PSR-是什么，PSR-1-2-4-7" class="headerlink" title="24.PSR 是什么，PSR-1, 2, 4, 7"></a>24.PSR 是什么，PSR-1, 2, 4, 7</h2><p>PSR-1—基础编码规范</p>
<p>PSR-2—编码风格规范</p>
<p>PSR-4—自动加载规范</p>
<p>PSR-7—HTTP 消息接口规范</p>
<hr>
<h2 id="25-如何获取客户端-IP-和服务端-IP-地址"><a href="#25-如何获取客户端-IP-和服务端-IP-地址" class="headerlink" title="25.如何获取客户端 IP 和服务端 IP 地址"></a>25.如何获取客户端 IP 和服务端 IP 地址</h2><p>客户端 IP<br>$_SERVER[‘REMOTE_ADDR’] 浏览当前页面的用户的 IP 地址</p>
<p>服务端 IP<br>$_SERVER[‘SERVER_ADDR’] 浏览当前页面的用户的 IP 地址</p>
<p>了解代理透传 实际IP 的概念<br>代理一般会在HTTP的Header中传输以下3个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REMOTE_ADDR // 访问端（有可能是用户，有可能是代理的）IP</span><br><span class="line">HTTP_X_FORWARDED_FOR // 用户是在哪个IP使用的代理（有可能存在，也可以伪造）</span><br><span class="line">HTTP_VIA // 代理服务器IP</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.manongjc.com/article/1129.html" target="_blank" rel="noopener">php客户端地址REMOTE_ADDR、HTTP_CLIENT_IP、HTTP_X_FORWARDED_FOR、HTTP_VIA 的区别及实例</a></p>
<hr>
<h2 id="26-如何开启-PHP-异常提示"><a href="#26-如何开启-PHP-异常提示" class="headerlink" title="26.如何开启 PHP 异常提示"></a>26.如何开启 PHP 异常提示</h2><p>php.ini 开启 display_errors 设置 error_reporting 等级</p>
<p>运行时，使用 ini_set(k, v); 动态设置</p>
<hr>
<h2 id="27-如何返回一个301重定向"><a href="#27-如何返回一个301重定向" class="headerlink" title="27.如何返回一个301重定向"></a>27.如何返回一个301重定向</h2><p>[WARNING] 一定当心设置 301 后脚本会继续执行，不要认为下面不会执行，必要时使用 die or exit<br>方法1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">header(&quot;HTTP/1.1 301 Moved Permanently&quot;);</span><br><span class="line"></span><br><span class="line">header(&quot;Location: /option-a&quot;);</span><br><span class="line"></span><br><span class="line">exit();</span><br></pre></td></tr></table></figure></p>
<p>方法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http_response_code(301);</span><br><span class="line"></span><br><span class="line">header(&apos;Location: /option-a&apos;);</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="28-如何获取扩展安装路径"><a href="#28-如何获取扩展安装路径" class="headerlink" title="28.如何获取扩展安装路径"></a>28.如何获取扩展安装路径</h2><p>phpinfo(); 页面查找 extension_dir</p>
<p>命令行 php -i |grep extension_dir</p>
<p>运行时 echo ini_get(‘extension_dir’);</p>
<hr>
<h2 id="29-字符串、数字比较大小的原理，注意-0-开头的8进制、0x-开头16进制"><a href="#29-字符串、数字比较大小的原理，注意-0-开头的8进制、0x-开头16进制" class="headerlink" title="29.字符串、数字比较大小的原理，注意 0 开头的8进制、0x 开头16进制"></a>29.字符串、数字比较大小的原理，注意 0 开头的8进制、0x 开头16进制</h2><p>字符串比较大小，从左(高位)至右，逐个字符 ASCII 比较。</p>
<p>字符串和数字比较，会先把字符串转换成数字类型，比如12se转换成12，abx转换成0，此时就不是字符的ASCII值与数字比较。0与任何不可转换成数字的字符串比较都是true。</p>
<p>两个不同进制的数字比较会转成十进制比较，得出这个结论是因为我在php中直接输出其他进制数字时均显示十进制格式。</p>
<p>猜想当数字字符串和非十进制数字比较大小时应该也是把数字转换成十进制形式再比较大小。</p>
<hr>
<h2 id="30-BOM-头是什么，怎么除去"><a href="#30-BOM-头是什么，怎么除去" class="headerlink" title="30.BOM 头是什么，怎么除去"></a>30.BOM 头是什么，怎么除去</h2><p>BOM头是放在UTF-8编码的文件的头部的三个字符（0xEF 0xBB 0xBF，即BOM）占用三个字节，<br>用来标识该文件属于UTF-8编码。现在已经有很多软件识别BOM头，但是还有些不能识别BOM头，<br>比如PHP就不能识别BOM头，所以PHP编码规范PSR-4：“无BOM的UTF-8格式”。<br>同时这也是用Windows记事本编辑UTF-8编码后执行就会出错的原因了（Windows记事本生成文件自带BOM）。<br>检测（具体查看超链接）<br>去除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function remove_utf8_bom($text)</span><br><span class="line">&#123;</span><br><span class="line">    $bom = pack(&apos;H*&apos;,&apos;EFBBBF&apos;);</span><br><span class="line">    $text = preg_replace(&quot;/^$bom/&quot;, &apos;&apos;, $text);</span><br><span class="line">    return $text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="31-什么是-MVC"><a href="#31-什么是-MVC" class="headerlink" title="31.什么是 MVC"></a>31.什么是 MVC</h2><p>MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p>
<p>MVC模式最早由Trygve Reenskaug在1978年提出，是施乐帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。</p>
<p>1）最上面的一层，是直接面向最终用户的”视图层”（View）。它是提供给用户的操作界面，是程序的外壳。</p>
<p>2）最底下的一层，是核心的”数据层”（Model），也就是程序需要操作的数据或信息。</p>
<p>3）中间的一层，就是”控制层”（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果。</p>
<hr>
<h2 id="32-依赖注入实现原理"><a href="#32-依赖注入实现原理" class="headerlink" title="32.依赖注入实现原理"></a>32.依赖注入实现原理</h2><p>一个用构造方法实现依赖注入的简单例子（原文链接）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">//依赖注入(Dependency injection)也叫控制反转（Inversion of Control）是一种设计模式，</span><br><span class="line">//这种模式用来减少程序间的耦合。</span><br><span class="line">//假设我们有个类，需要用到数据库连接，我们可能这样写</span><br><span class="line"></span><br><span class="line">class UseDataBase &#123;</span><br><span class="line">    protected $adapter;</span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        $this-&gt;adapter=new MySqlAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getList() &#123;</span><br><span class="line">        $this-&gt;adapter-&gt;query(&quot;sql语句&quot;);//使用MySqlAdapter类中的query方法；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MySqlAdapter&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//我们可以通过依赖注入来重构上面这个例子</span><br><span class="line"></span><br><span class="line">class UseDataBase &#123;</span><br><span class="line">    protected $adapter;</span><br><span class="line">    public function __construct(MySqlAdapter $adapter) &#123;</span><br><span class="line">        $this-&gt;adapter=$adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getList() &#123;</span><br><span class="line">        $this-&gt;adapter-&gt;query(&quot;sql语句&quot;);//使用MySqlAdapter类中的query方法；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MySqlAdapter&#123;&#125;;</span><br><span class="line">//但是，当我们有很多种数据库时，上面的这种方式就达不到要求或者要写很多个usedatabase类,所以我们再重构上面的这个例子</span><br><span class="line"></span><br><span class="line">class UseDataBase &#123;</span><br><span class="line">    protected $adapter;</span><br><span class="line">    poublic function __construct(AdapterInterface $adapter) &#123;</span><br><span class="line">        $this-&gt;adapter=$adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getList() &#123;</span><br><span class="line">        $this-&gt;adapter-&gt;query(&quot;sql语句&quot;);//使用AdapterInterface类中的query方法；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface AdapterInterface&#123;&#125;;</span><br><span class="line"></span><br><span class="line">class MySqlAdapter implements AdapterInterface&#123;&#125;;</span><br><span class="line"></span><br><span class="line">class MSsqlAdapter implements AdapterInterface&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//这样的话，当要使用不同的数据库时，我们只需要添加数据库类实现适配器接口就够了，</span><br><span class="line"></span><br><span class="line">usedatabase类则不需要动。</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>因为大多数应用程序都是由两个或者更多的类通过彼此合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么将导致代码高度耦合并且难以维护和调试。</p>
<hr>
<h2 id="33-如何异步执行命令"><a href="#33-如何异步执行命令" class="headerlink" title="33.如何异步执行命令"></a>33.如何异步执行命令</h2><p>不明白作者提出的这个问题是想问shell异步执行还是php异步执行脚本。</p>
<p>Shell异步执行：</p>
<p>bash提供了一个内置的命令来帮助管理异步执行。wait命令可以让父脚本暂停，直到指定的进程（比如子脚本）结束。</p>
<p>Php异步执行脚本：<br>方法1：<br>必须在php.ini中注释掉disable_functions，这样popen函数才能使用。该函数打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。所以可以通过调用它，但忽略它的输出。</p>
<p>resource popen(string $command, string $mode)</p>
<p>$command：linux命令，$mode：模式。</p>
<p>返回一个和 fopen() 所返回的相同的文件指针，<br>只不过它是单向的（只能用于读或写）并且必须用 pclose() 来关闭。<br>此指针可以用于fgets()，fgetss() 和 fwrite()。</p>
<p>当模式为 ‘r’，返回的文件指针等于命令的 STDOUT，当模式为 ‘w’，<br>返回的文件指针等于命令的 STDIN。如果出错返回 FALSE。</p>
<p>这种方法不能通过HTTP协议请求另外的一个WebService，只能执行本地的脚本文件。<br>并且只能单向打开，无法穿大量参数给被调用脚本。<br>并且如果，访问量很高的时候，会产生大量的进程。<br>如果使用到了外部资源，还要自己考虑竞争。</p>
<p>方法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ch = curl_init();        </span><br><span class="line">$curl_opt = array(</span><br><span class="line">     CURLOPT_URL=&gt;&apos;hostname/syncStock.php&apos;,</span><br><span class="line">     CURLOPT_RETURNTRANSFER=&gt;1,</span><br><span class="line">     CURLOPT_TIMEOUT=&gt;1,</span><br><span class="line">);        </span><br><span class="line">curl_setopt_array($ch, $curl_opt);        </span><br><span class="line"></span><br><span class="line">$out = curl_exec($ch);        </span><br><span class="line">curl_close($ch);</span><br></pre></td></tr></table></figure></p>
<p>原理：通过curl去调用一个php脚本，如果响应时间超过了1秒钟，则断开该连接，<br>程序继续往下走而syncStock.php这个脚本还在继续往下执行。</p>
<p>缺点：必须设置CURLOPT_TIMEOUT=&gt;1这个属性，所以导致客户端必须至少等待1秒。<br>但是这个属性不设置又不行，不设置的话，就会一直等待响应。就没有异步的效果了。</p>
<hr>
<h2 id="34-模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）"><a href="#34-模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）" class="headerlink" title="34.模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）"></a>34.模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）</h2><p>模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。</p>
<p>模板引擎的实现方式有很多，最简单的是“置换型”模板引擎，这类模板引擎只是将指定模板内容（字符串）中的特定标记（子字符串）替换一下便生成了最终需要的业务数据（比如网页）。</p>
<p>置换型模板引擎实现简单，但其效率低下，无法满足高负载的应用需求（比如有海量访问的网站），因此还出现了“解释型”模板引擎和“编译型”模板引擎等。</p>
<p>模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这就大大提升了开发效率，良好的设计也使得代码重用变得更加容易。</p>
<p>我们司空见惯的模板安装卸载等概念，基本上都和模板引擎有着千丝万缕的联系。模板引擎不只是可以让你实现代码分离（业务逻辑代码和用户界面代码），也可以实现数据分离（动态数据与静态数据），还可以实现代码单元共享（代码重用），甚至是多语言、动态页面与静态页面自动均衡（SDE）等等与用户界面可能没有关系的功能。</p>
<p>Smarty：</p>
<p>Smarty是一个php模板引擎。更准确的说，它分离了逻辑程序和外在的内容，提供了一种易于管理的方法。Smarty总的设计理念就是分离业务逻辑和表现逻辑，优点概括如下：</p>
<p>　　速度——相对于其他的模板引擎技术而言，采用Smarty编写的程序可以获得最大速度的提高</p>
<p>　　编译型——采用Smarty编写的程序在运行时要编译成一个非模板技术的PHP文件，这个文件采用了PHP与HTML混合的方式，在下一次访问模板时将Web请求直接转换到这个文件中，而不再进行模板重新编译(在源程序没有改动的情况下)，使用后续的调用速度更快</p>
<p>　　缓存技术——Smarty提供了一种可选择使用的缓存技术，它可以将用户最终看到的HTML文件缓存成一个静态的HTML页面。当用户开启Smarty缓存时，并在设定的时间内，将用户的Web请求直接转换到这个静态的HTML文件中来，这相当于调用一个静态的HTML文件</p>
<p>　　插件技术——Smarty模板引擎是采用PHP的面向对象技术实现，不仅可以在原代码中修改，还可以自定义一些功能插件(按规则自定义的函数)</p>
<p>　　强大的表现逻辑——在Smarty模板中能够通过条件判断以及迭代地处理数据，它实际上就是种程序设计语言，但语法简单，设计人员在不需要预备的编程知识前提下就可以很快学会</p>
<p>　　模板继承——模板的继承是Smarty3的新事物。在模板继承里，将保持模板作为独立页面而不用加载其他页面，可以操纵内容块继承它们。这使得模板更直观、更有效和易管理</p>
<p>Twig：</p>
<p>Twig是一个灵活，快速，安全的PHP模板语言。它将模板编译成经过优化的原始PHP代码。Twig拥有一个Sandbox模型来检测不可信的模板代码。Twig由一个灵活的词法分析器和语法分析器组成，可以让开发人员定义自己的标签，过滤器并创建自己的DSL。</p>
<p>Blade：</p>
<p>Blade 是 Laravel 提供的一个简单而又强大的模板引擎。和其他流行的 PHP 模板引擎不同，Blade 并不限制你在视图中使用原生 PHP 代码。所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade 基本上不会给你的应用增加任何负担。Blade 视图文件使用 .blade.php 作为文件扩展名，被存放在 resources/views 目录。</p>
<hr>
<h2 id="35-如何实现链式操作-obj-gt-w-gt-m-gt-d"><a href="#35-如何实现链式操作-obj-gt-w-gt-m-gt-d" class="headerlink" title="35.如何实现链式操作 $obj-&gt;w()-&gt;m()-&gt;d();"></a>35.如何实现链式操作 $obj-&gt;w()-&gt;m()-&gt;d();</h2><p>简单实现（关键通过做完操作后return $this;）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Sql&#123;</span><br><span class="line">    private $sql=array(</span><br><span class="line">        &quot;from&quot;=&gt;&quot;&quot;,</span><br><span class="line">        &quot;where&quot;=&gt;&quot;&quot;,</span><br><span class="line">        &quot;order&quot;=&gt;&quot;&quot;,</span><br><span class="line">        &quot;limit&quot;=&gt;&quot;&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    public function from($tableName) &#123;</span><br><span class="line">        $this-&gt;sql[&quot;from&quot;]=&quot;FROM &quot;.$tableName;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function where($_where=&apos;1=1&apos;) &#123;</span><br><span class="line">        $this-&gt;sql[&quot;where&quot;]=&quot;WHERE &quot;.$_where;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function order($_order=&apos;id DESC&apos;) &#123;</span><br><span class="line">        $this-&gt;sql[&quot;order&quot;]=&quot;ORDER BY &quot;.$_order;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function limit($_limit=&apos;30&apos;) &#123;</span><br><span class="line">        $this-&gt;sql[&quot;limit&quot;]=&quot;LIMIT 0,&quot;.$_limit;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function select($_select=&apos;*&apos;) &#123;</span><br><span class="line">        return &quot;SELECT &quot;.$_select.&quot; &quot;.(implode(&quot; &quot;,$this-&gt;sql));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$sql =new Sql();</span><br><span class="line"></span><br><span class="line">echo $sql-&gt;from(&quot;testTable&quot;)-&gt;where(&quot;id=1&quot;)-&gt;order(&quot;id DESC&quot;)-&gt;limit(10)-&gt;select();</span><br><span class="line">//输出 SELECT * FROM testTable WHERE id=1 ORDER BY id DESC LIMIT 0,10</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>利用__call()方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">    public $value;</span><br><span class="line"></span><br><span class="line">    public function __construct($str=null)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;value = $str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $args)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;value = call_user_func($name, $this-&gt;value, $args[0]);</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function strlen()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        return strlen($this-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$str = new String(&apos;01389&apos;);</span><br><span class="line"></span><br><span class="line">echo $str-&gt;trim(&apos;0&apos;)-&gt;strlen();</span><br><span class="line"></span><br><span class="line">// 输出结果为 4；trim(&apos;0&apos;)后$str为&quot;1389&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="36-Xhprof-、Xdebug-性能调试工具使用"><a href="#36-Xhprof-、Xdebug-性能调试工具使用" class="headerlink" title="36.Xhprof 、Xdebug 性能调试工具使用"></a>36.Xhprof 、Xdebug 性能调试工具使用</h2><p>XHProf：</p>
<p>XHProf 是一个轻量级的分层性能测量分析器。 在数据收集阶段，它跟踪调用次数与测量数据，展示程序动态调用的弧线图。 它在报告、后期处理阶段计算了独占的性能度量，例如运行经过的时间、CPU 计算时间和内存开销。 函数性能报告可以由调用者和被调用者终止。 在数据搜集阶段 XHProf 通过调用图的循环来检测递归函数，通过赋予唯一的深度名称来避免递归调用的循环。</p>
<p>XHProf 包含了一个基于 HTML 的简单用户界面(由 PHP 写成)。 基于浏览器的用户界面使得浏览、分享性能数据结果更加简单方便。 同时也支持查看调用图。</p>
<p>XHProf 的报告对理解代码执行结构常常很有帮助。 比如此分层报告可用于确定在哪个调用链里调用了某个函数。</p>
<p>XHProf 对两次运行进行比较（又名 “diff” 报告），或者多次运行数据的合计。 对比、合并报告，很像针对单次运行的“平式视图”性能报告，就像“分层式视图”的性能报告。</p>
<p>Xdebug：</p>
<p>Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，</p>
<p>调试和分析PHP程序的运行状况。Xdebug的基本功能包括在错误条件下显示堆栈轨迹，最大嵌套级别和时间跟踪。</p>
<hr>
<h2 id="37-索引数组-1-2-与关联数组-‘k1’-gt-1-‘k2’-gt-2-有什么区别"><a href="#37-索引数组-1-2-与关联数组-‘k1’-gt-1-‘k2’-gt-2-有什么区别" class="headerlink" title="37.索引数组 [1, 2] 与关联数组 [‘k1’=&gt;1, ‘k2’=&gt;2] 有什么区别"></a>37.索引数组 [1, 2] 与关联数组 [‘k1’=&gt;1, ‘k2’=&gt;2] 有什么区别</h2><p>索引数组的默认key是从0开始的数字，可省略不写；<br>而关联数组的key是字符串，必须主动指明，字符串内容可为数字也可为其他字符。</p>
<h2 id="38-为什么使用缓存"><a href="#38-为什么使用缓存" class="headerlink" title="38.为什么使用缓存"></a>38.为什么使用缓存</h2><p>提升性能：使用缓存可以跳过数据库查询，分布式系统中可以跳过多次网络开销。</p>
<p>在读多写少的场景下，可以有效的提高性能，降低数据库等系统的压力。</p>
<h3 id="缓存的适用场景"><a href="#缓存的适用场景" class="headerlink" title="缓存的适用场景"></a>缓存的适用场景</h3><p>1：数据不需要强一致性</p>
<p>2：读多写少，并且读取得数据重复性较高</p>
<h3 id="缓存的正确打开方式"><a href="#缓存的正确打开方式" class="headerlink" title="缓存的正确打开方式"></a>缓存的正确打开方式</h3><p>1：Cache Aside 同时更新缓存和数据库</p>
<p>2：Read/Write Through 先更新缓存，缓存负责同步更新数据库</p>
<p>3：Write Behind Caching 先更新缓存，缓存负责异步更新数据库</p>
<h3 id="下面具体分析每种模式"><a href="#下面具体分析每种模式" class="headerlink" title="下面具体分析每种模式"></a>下面具体分析每种模式</h3><p>一、Cache Aside 更新模式</p>
<p>这是最常用的缓存模式了，具体的流程是：</p>
<p>读取：应用程序先从 cache 取数据，取到后成功返回；没有得到，则从数据库中取数据，成功后，放到缓存中。</p>
<p>更新：先把数据存到数据库中，再清理缓存使其失效。</p>
<p>不过这种模式有几个变种：</p>
<p>第一，如果先更新数据库再更新缓存。假设两个并发更新操作，数据库先更新的反而后更新缓存，数据库后更新的反而先更新缓存。这样就会造成数据库和缓存中的数据不一致，应用程序中读取的都是脏数据。</p>
<p>第二，先删除缓存再更新数据库。假设一个更新操作先删除了缓存，一个读操作没有命中缓存，从数据库中取出数据并且更新回缓存，再然后更新操作完成数据库更新。这时数据库和缓存中的数据是不一致的，应用程序中读取的都是原来的数据。</p>
<p>第三，先更新数据库再删除缓存。假设一个读操作没有命中缓存，然后读取数据库的老数据。同时有一个并发更新操作，在读操作之后更新了数据库并清空了缓存。此时读操作将之前从数据库中读取出的老数据更新回了缓存。这时数据库和缓存中的数据也是不一致的。</p>
<p>但是一般情况下，缓存用于读多写少的场景，所以第三种这种情况其实是小概率会出现的。</p>
<p>二、Read/Write Through 更新模式</p>
<p>Read Through 模式就是在查询操作中更新缓存，缓存服务自己来加载。</p>
<p>Write Through 模式和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库（这是一个同步操作）。</p>
<p>三、Write Behind Caching 更新模式</p>
<p>Write Behind Caching 更新模式就是在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。但其带来的问题是，数据不是强一致性的，而且可能会丢失。</p>
<h3 id="总结，三种缓存模式的优缺点："><a href="#总结，三种缓存模式的优缺点：" class="headerlink" title="总结，三种缓存模式的优缺点："></a>总结，三种缓存模式的优缺点：</h3><p>Cache Aside 更新模式实现起来比较简单，最常用，实时性也高，但是需要应用需要关注核实加载数据进入缓存 。</p>
<p>Read/Write Through 更新模式只需要维护一个缓存，对应用屏蔽掉了缓存的细节，实时性也高。但是实现起来要复杂一些。</p>
<p>Write Behind Caching 吞吐量很高，多次操作可以合并。但是数据可能会丢失，例如系统断电等，实现起来最复杂。</p>
<hr>

      
    </div>

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/20/php知识点/" data-id="cjxmd3cfp000w6vhnk3wgcx4q" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>








  
    <article id="post-php常用函数" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/php常用函数/" class="article-date">
  <time class="post-time" datetime="2016-07-05T16:00:00.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br>
    <span class="post-day">06</span>
  </time>
</a>
  </div>

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/php常用函数/">php常用函数</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2016/07/06/php常用函数/" class="leancloud_visitors" data-flag-title="php常用函数">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="php常用函数"><a href="#php常用函数" class="headerlink" title="php常用函数"></a>php常用函数</h1><hr>
<h2 id="1-数组函数"><a href="#1-数组函数" class="headerlink" title="1.数组函数"></a>1.数组函数</h2><ul>
<li><a href="http://php.net/manual/zh/function.array-chunk.php" target="_blank" rel="noopener">array_chunk</a> // 将一个数组分割成多个</li>
<li><a href="http://php.net/manual/zh/function.array-column.php" target="_blank" rel="noopener">array_column</a> // 返回数组中指定的一列</li>
<li><a href="http://php.net/manual/zh/function.array-combine.php" target="_blank" rel="noopener">array_combine</a> // 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值（另一种意义的合并数组）</li>
<li><a href="http://php.net/manual/zh/function.array-flip.php" target="_blank" rel="noopener">array_flip</a> // 交换数组中的键和值</li>
<li><a href="http://php.net/manual/zh/function.array-key-exists.php" target="_blank" rel="noopener">array_key_exists</a> // 检查数组里是否有指定的键名或索引</li>
<li><a href="http://php.net/manual/zh/function.array-key-first.php" target="_blank" rel="noopener">array_key_first</a> // 返回数组第一个键的键名</li>
<li><a href="http://php.net/manual/zh/function.array-key-last.php" target="_blank" rel="noopener">array_key_last</a> // 返回数组最后一个键的键名</li>
<li><a href="http://php.net/manual/zh/function.array-keys.php" target="_blank" rel="noopener">array_keys</a> // 返回数组键名</li>
<li><a href="http://php.net/manual/zh/function.array-merge.php" target="_blank" rel="noopener">array_merge</a> // 合并一个或多个数组 </li>
<li><a href="http://php.net/manual/zh/function.array-pop.php" target="_blank" rel="noopener">array_pop</a> // 弹出数组最后一个单元；出栈；删除数组最后一个单元</li>
<li><a href="http://php.net/manual/zh/function.array-push.php" target="_blank" rel="noopener">array_push</a> // 将一个或多个单元压入数组的末尾；入栈；合并数组</li>
<li><a href="http://php.net/manual/zh/function.array-rand.php" target="_blank" rel="noopener">array_rand</a> // 从数组中随机取出一个或多个单元</li>
<li><a href="http://php.net/manual/zh/function.array-reverse.php" target="_blank" rel="noopener">array_reverse</a> // 返回单元顺序相反的数组</li>
<li><a href="http://php.net/manual/zh/function.array-search.php" target="_blank" rel="noopener">array_search</a> // 在数组中搜索给定的值，如果成功则返回首个相应的键名</li>
<li><a href="http://php.net/manual/zh/function.array-shift.php" target="_blank" rel="noopener">array_shift</a> // 将数组开头的单元移出数组</li>
<li><a href="http://php.net/manual/zh/function.array-slice.php" target="_blank" rel="noopener">array_slice</a> // 从数组中取出一段</li>
<li><a href="http://php.net/manual/zh/function.array-sum.php" target="_blank" rel="noopener">array_sum</a> // 对数组中所有值求和</li>
<li><a href="http://php.net/manual/zh/function.array-unique.php" target="_blank" rel="noopener">array_unique</a> // 移除数组中重复的值</li>
<li><a href="http://php.net/manual/zh/function.array-unshift.php" target="_blank" rel="noopener">array_unshift</a> // 在数组开头插入一个或多个单元</li>
<li><a href="http://php.net/manual/zh/function.array-values.php" target="_blank" rel="noopener">array_values</a> // 返回数组中所有的值</li>
<li><a href="http://php.net/manual/zh/function.arsort.php" target="_blank" rel="noopener">arsort</a> // 对数组进行逆向排序并保持索引关系</li>
<li><a href="http://php.net/manual/zh/function.asort.php" target="_blank" rel="noopener">asort</a> // 对数组进行排序并保持索引关系</li>
<li><a href="http://php.net/manual/zh/function.count.php" target="_blank" rel="noopener">count</a> // 计算数组中的单元数目，或对象中的属性个数</li>
<li><a href="http://php.net/manual/zh/function.current.php" target="_blank" rel="noopener">current</a> // 返回数组中的当前单元</li>
<li><a href="http://php.net/manual/zh/function.in-array.php" target="_blank" rel="noopener">in_array</a> // 检查数组中是否存在某个值</li>
<li><a href="http://php.net/manual/zh/function.krsort.php" target="_blank" rel="noopener">krsort</a> // 对数组按照键名逆向排序</li>
<li><a href="http://php.net/manual/zh/function.ksort.php" target="_blank" rel="noopener">ksort</a> // 对数组按照键名排序</li>
<li><a href="http://php.net/manual/zh/function.list.php" target="_blank" rel="noopener">list</a> // 把数组中的值赋给一组变量</li>
<li><a href="http://php.net/manual/zh/function.shuffle.php" target="_blank" rel="noopener">shuffle</a> // 打乱数组</li>
<li><a href="http://php.net/manual/zh/function.sort.php" target="_blank" rel="noopener">sort</a> // 对数组排序</li>
<li><a href="http://php.net/manual/zh/function.uasort.php" target="_blank" rel="noopener">uasort</a> // 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联</li>
<li><a href="http://php.net/manual/zh/function.uksort.php" target="_blank" rel="noopener">uksort</a> // 使用用户自定义的比较函数对数组中的键名进行排序</li>
<li><a href="http://php.net/manual/zh/function.usort.php" target="_blank" rel="noopener">usort</a> // 使用用户自定义的比较函数对数组中的值进行排序</li>
</ul>
<hr>
<h2 id="2-string-字符串-函数"><a href="#2-string-字符串-函数" class="headerlink" title="2.string(字符串)函数"></a>2.string(字符串)函数</h2><ul>
<li><a href="http://php.net/manual/zh/function.chunk-split.php" target="_blank" rel="noopener">chunk_split</a> // 将字符串分割成小块</li>
<li><a href="http://php.net/manual/zh/function.explode.php" target="_blank" rel="noopener">explode</a> // 使用一个字符串分割另一个字符串</li>
<li><a href="http://php.net/manual/zh/function.implode.php" target="_blank" rel="noopener">implode</a> // 将一个一维数组的值转化为字符串</li>
<li><a href="http://php.net/manual/zh/function.lcfirst.php" target="_blank" rel="noopener">lcfirst</a> // 使一个字符串的第一个字符小写</li>
<li><a href="http://php.net/manual/zh/function.ltrim.php" target="_blank" rel="noopener">ltrim</a> // 删除字符串开头的空白字符（或其他字符）</li>
<li><a href="http://php.net/manual/zh/function.md5.php" target="_blank" rel="noopener">md5</a> // 计算字符串的 MD5 散列值</li>
<li><a href="http://php.net/manual/zh/function.money-format.php" target="_blank" rel="noopener">money_format</a> // 将数字格式化成货币字符串</li>
<li><a href="http://php.net/manual/zh/function.nl2br.php" target="_blank" rel="noopener">nl2br</a> // 在字符串所有新行之前插入 HTML 换行标记</li>
<li><a href="http://php.net/manual/zh/function.number-format.php" target="_blank" rel="noopener">number_format</a> // 以千位分隔符方式格式化一个数字</li>
<li><a href="http://php.net/manual/zh/function.ord.php" target="_blank" rel="noopener">ord</a> // 返回字符的 ASCII 码值</li>
<li><a href="http://php.net/manual/zh/function.rtrim.php" target="_blank" rel="noopener">rtrim</a> // 删除字符串末端的空白字符（或者其他字符）</li>
<li><a href="http://php.net/manual/zh/function.str-replace.php" target="_blank" rel="noopener">str_replace</a> // 子字符串替换</li>
<li><a href="http://php.net/manual/zh/function.str-ireplace.php" target="_blank" rel="noopener">str_ireplace</a> // str_replace 的忽略大小写版本</li>
<li><a href="http://php.net/manual/zh/function.str-repeat.php" target="_blank" rel="noopener">str_repeat</a> // 重复一个字符串</li>
<li><a href="http://php.net/manual/zh/function.str-shuffle.php" target="_blank" rel="noopener">str_shuffle</a> // 随机打乱一个字符串</li>
<li><a href="http://php.net/manual/zh/function.str-split.php" target="_blank" rel="noopener">str_split</a> // 将字符串转换为数组</li>
<li><a href="http://php.net/manual/zh/function.stripos.php" target="_blank" rel="noopener">stripos</a> // 查找字符串首次出现的位置（不区分大小写）</li>
<li><a href="http://php.net/manual/zh/function.strpos.php" target="_blank" rel="noopener">strpos</a> // 查找字符串首次出现的位置</li>
<li><a href="http://php.net/manual/zh/function.strstr.php" target="_blank" rel="noopener">strstr</a> // 查找字符串的首次出现</li>
<li><a href="http://php.net/manual/zh/function.stristr.php" target="_blank" rel="noopener">stristr</a> // strstr 函数的忽略大小写版本</li>
<li><a href="http://php.net/manual/zh/function.strlen.php" target="_blank" rel="noopener">strlen</a> // 获取字符串长度</li>
<li><a href="http://php.net/manual/zh/function.strrchr.php" target="_blank" rel="noopener">strrchr</a> // 查找指定字符在字符串中的最后一次出现</li>
<li><a href="http://php.net/manual/zh/function.strrev.php" target="_blank" rel="noopener">strrev</a> // 反转字符串</li>
<li><a href="http://php.net/manual/zh/function.strripos.php" target="_blank" rel="noopener">strripos</a> // 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）</li>
<li><a href="http://php.net/manual/zh/function.strrpos.php" target="_blank" rel="noopener">strrpos</a> // 计算指定字符串在目标字符串中最后一次出现的位置</li>
<li><a href="http://php.net/manual/zh/function.strtok.php" target="_blank" rel="noopener">strtok</a> // 标记分割字符串</li>
<li><a href="http://php.net/manual/zh/function.strtolower.php" target="_blank" rel="noopener">strtolower</a> // 将字符串转化为小写</li>
<li><a href="http://php.net/manual/zh/function.strtoupper.php" target="_blank" rel="noopener">strtoupper</a> // 将字符串转化为大写</li>
<li><a href="http://php.net/manual/zh/function.substr-count.php" target="_blank" rel="noopener">substr_count</a> // 计算字串出现的次数</li>
<li><a href="http://php.net/manual/zh/function.substr-replace.php" target="_blank" rel="noopener">substr_replace</a> // 替换字符串的子串</li>
<li><a href="http://php.net/manual/zh/function.substr.php" target="_blank" rel="noopener">substr</a> // 返回字符串的子串</li>
<li><a href="http://php.net/manual/zh/function.trim.php" target="_blank" rel="noopener">trim</a> //  去除字符串首尾处的空白字符（或者其他字符）</li>
<li><a href="http://php.net/manual/zh/function.ucfirst.php" target="_blank" rel="noopener">ucfirst</a> // 将字符串的首字母转换为大写</li>
<li><a href="http://php.net/manual/zh/function.ucwords.php" target="_blank" rel="noopener">ucwords</a> // 将字符串中每个单词的首字母转换为大写</li>
<li><a href="http://php.net/manual/zh/function.wordwrap.php" target="_blank" rel="noopener">wordwrap</a> // 打断字符串为指定数量的字串</li>
</ul>
<hr>

      
    </div>

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/06/php常用函数/" data-id="cjxmd3ccy00076vhn38s7hyl0" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>








  
    <article id="post-名词备忘" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/05/名词备忘/" class="article-date">
  <time class="post-time" datetime="2016-07-04T16:00:00.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br>
    <span class="post-day">05</span>
  </time>
</a>
  </div>

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/05/名词备忘/">名词备忘</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/通用/">通用</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2016/07/05/名词备忘/" class="leancloud_visitors" data-flag-title="名词备忘">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">数组 = 数组 = 集合</span><br><span class="line">数列 = 规则数组</span><br><span class="line">函数F(x)的F只是名字</span><br><span class="line">值域 = 函数值范围</span><br><span class="line">定义域 = x取值范围</span><br><span class="line">键名 key</span><br><span class="line">值 value</span><br><span class="line">索引</span><br><span class="line">数组中的单元数目</span><br><span class="line">出栈</span><br><span class="line">入栈</span><br><span class="line">对象中的属性个数</span><br><span class="line">迭代 = 循环</span><br></pre></td></tr></table></figure>

      
    </div>

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/05/名词备忘/" data-id="cjxmd3cd2000a6vhnplw0ib9l" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/通用/">通用</a></li></ul>

    </footer>
  </div>
  
</article>








  
    <article id="post-hexo使用步骤" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/04/hexo使用步骤/" class="article-date">
  <time class="post-time" datetime="2016-07-03T16:00:00.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br>
    <span class="post-day">04</span>
  </time>
</a>
  </div>

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/04/hexo使用步骤/">hexo使用步骤</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2016/07/04/hexo使用步骤/" class="leancloud_visitors" data-flag-title="hexo使用步骤">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/04/hexo使用步骤/" data-id="cjxmd3ccg00016vhnnj7xs4l9" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>

    </footer>
  </div>
  
</article>








  

</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">xiao-linxin</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/search" title="search">
            <li>搜索</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://img.xingyiss.com/IMG_4296.JPG">
    <h2 class="author">xiao-linxin</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>7</strong><br>文章</div></a>
      <a href="/categories"><div><strong>3</strong><br>分类</div></a>
      <a href="/tags"><div><strong>3</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/xiao-linxin" target="_blank" title="Github">
          Github
        </a>
      
        <a class="hvr-bounce-in" href="https://gitee.com/xiao_linxin" target="_blank" title="Gitee">
          Gitee
        </a>
      
    </div>

    <div class="friend-link">
      <h2></h2>
      
    </div>
  </div>
</div>

  

  <div class="widget-wrap">
      {"title":"404","date":"2019-01-23T18:11:10.000Z","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2019-01-24 02:11:10\n---\n","updated":"2019-01-23T18:11:10.000Z","path":"404/index.html","comments":true,"layout":"page","_id":"cjxmd3ccd00006vhnwe3vicj1","content":"","site":{"data":{}},"excerpt":"","more":"","permalink":"http://yoursite.com/404/index.html","full_source":"/Users/yoko/Documents/hexo/blog/source/404/index.md","__page":true,"lang":"zh-CN","canonical_path":"404/index.html"}
      
  </div>
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2016 - 2019 <a href="https://github.com/xiao-linxin">xiao-linxin</a><br>
      Powered by <a href="http://hexo.io/" target="_blank">hexo</a> and <a href="https://github.com/ShanaMaid/hexo-theme-shana">shana</a> and <a href="https://github.com/">github</a>.
      <!--由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 |-->
      <!--主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>-->
      
        | 站长统计 <script>

          var cnzz_s_tag =document.createElement('script');

          cnzz_s_tag.type ='text/javascript';

          cnzz_s_tag.async =true;

          cnzz_s_tag.charset= 'utf-8';

          cnzz_s_tag.src ='https://w.cnzz.com/c.php?id=1276097034&async=1';

          var root_s =document.getElementsByTagName('script')[0];

          root_s.parentNode.insertBefore(cnzz_s_tag,root_s);

        </script>
      
    </div>

  </div>
</footer>

    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="https://github.com/xiao-linxin" title="" class="menuItem">Github</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">关于我</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>




  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("XzWyJ3sWCsDg9U9NbPNHkyzQ-gzGzoHsz", "V4KNTPdo7AO8gtV2m7hxkE12");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.article-title').length > 1) {
        showTime(Counter);
      }
    });
  </script>





  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":80,"height":160,"hOffset":0,"vOffset":-40},"mobile":{"show":true,"scale":0.2,"motion":true}});</script></body>
</html>